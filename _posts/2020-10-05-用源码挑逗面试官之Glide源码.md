---
layout:     post
title:      用源码挑逗面试官之Glide源码解读
subtitle:   深入理解Glide源码以及设计思想，让你在面试中无所畏惧
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - 源码
    - OkHttp
typora-root-url: ..

---

## 前言

现在出去面试官都喜欢问源码，尤其是OkHttp，Glide这种我们日常开发中最常用的框架，更是喜欢追问个不停。恨不得让你当场手写一个原版出来。我真是一言难尽

为啥？大家都这么忙，谁不想当一条咸鱼啊，无产阶级何必为难无产阶级呢。

不过，吐槽归吐槽，学习归学习，我们还是要认真学习，毕竟有助于我们提升姿势水平~



![](/img/emoji/出发.jpg)

## Glide的简单使用

Glide的使用非常简单，一行代码搞定：

```kotlin
Glide.with(this).load(path).into(imgView)
```

相信很多小伙伴刚接触的时候都惊呆了，怎么可以这么简洁，这么优雅，真的应了那句话，代码是一种艺术。

不过简洁有简洁的好处，也有弊端，就是不利于我们学习。

其实真正的代码应该是这样的：

```kotlin
val requestManager:RequestManager = Glide.with(this)
val requestBuilder:RequestBuilder<Drawable> = requestManager.load(path)
val viewTarget:ViewTarget<ImageView,Drawable> = requestBuilder.into(imgView)
```

等等，这都是啥？

简洁的链式调用就这样被我破坏了。其实真正的用法应该是这样，只不过Glide封装的非常好，所以省略了很多细节，我们可以无感知的一行代码完成图片加载，但今天我们就要拆开轮子，看看轮子到底是如何运转的。

## With

首先便是with方法，我们看一下整个with方法的定义

```kotlin
public static RequestManager with(@NonNull Context context){
    return getRetriever(context).get(context);
}
public static RequestManager with(@NonNull Activity activity){
    return getRetriever(activity).get(activity);
}
public static RequestManager with(@NonNull Fragment fragment){
    return getRetriever(fragment.getContext()).get(fragment);
}
```

还有几个重载方法，不过我只挑出来具有重大代表意义的。这个方法好像既能传Activity，也能传Fragment，甚至能传Application。那么区别是什么呢？

可以看到，无论传什么参数，获取到的都是RequestManager对象，见名思义，这个对象就是图片的请求管理器。既然都是RequestManager对象，我们直接传入Context不就行了么？干嘛还得分开来呢？

这里面就涉及到一个很重要的问题，也是我们在做耗时操作的时候避不开的问题，就是生命周期的管理问题。

什么是生命周期管理问题？

![](/img/emoji/别急我慢慢说.jpg)

兄dei看来你还是活的够久啊，你想如果你在请求一个很大的妹子图片，但是这个时候突然你女朋友过来了，能让他看见你在看妹子图片么？当然不能，这个时候你肯定得手忙脚乱的关掉app，可是这个时候请求已经发出去了，咋办？如果我们什么都不管的话，那肯定会造成内存泄露。

所以为什么Glide要重载好几个不同的方法？为的就是应对这个情况，当请求已经不再需要的时候，去取消请求，防止内存泄露。所以聪明的你应该第一时间想到Lifecycle组件，它能够很好的感知生命周期。

Glide具体是如何去做的呢？

我们首先看Glide如何去感知Activity的生命周期的

