---
layout:     post
title:      什么,不看源码也能彻底应对RxJava面试?
subtitle:   从设计角度，以及图示轻松理解RxJava
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - 源码
    - RxJava
typora-root-url: ..

---

## 前言

RxJava从几年前开始流行，以其链式风格的调用和强大的操作符而闻名于世。当然，最重要的是异步切换简单到了令人发指的地步。但是，凡事都有两面性。RxJava的上手难度也是特别陡峭的，而且经常会遇到团队里其他人对于RxJava的掌握不是很熟练。

这一切的根源，都来源于它的设计思想，**事件驱动型**编程。

什么？看不懂？

没关系，接下来我一行源码也不会贴出来，让你自己就能手撸一个RxJava。

让你以后在遇到RxJava的面试题，你直接告诉他，面试官，要不这样别问了，我给你手写一个RxJava你看可还行？

阅读本文需要有一定的RxJava基础。起码会简单的使用



![](/img/emoji/出发.jpg)

## 观察者模式

要理解RxJava，必须要理解一个模式，就是观察者模式。

什么是观察者模式呢？

就好比搞公众号，你订阅了一个公众号，此时，你是观察者，公众号是被观察者。你订阅公众号简而言之就是你与公众号建立了一个联系，公众号更新文章后就会推送给所有订阅的人，其中也包括你。

两个角色，一个关系。

被观察者，有变化通知给**订阅**了的观察者。对应公众号

观察者，主动与一个被观察者建立**订阅关系**。对应你

那么代码上该如何实现呢？

## 简单实现观察者模式

创建一个观察者

```kotlin
class Observer {
    fun change(){
        println("我是观察者")
    }
}
```

创建一个被观察者

```kotlin
class Observable {
	//观察者集合
    private val observerList= mutableListOf<Observer>()
	//订阅方法
    fun subscribe(observer: Observer){
        observerList.add(observer)
    }
    //通知所有观察者
    fun notifyObserver(){
        observerList.forEach {
            it.change()
        }
    }
}
```

等等，你这被观察者怎么一堆东西？

我们一会再说这个里面的东西

```kotlin
fun main() {
    //创建一个被观察者
    val observable = Observable()
    //创建一个观察者
    val observer=Observer()
    //被观察者订阅观察者
    observable.subscribe(observer)
    //被观察者通知观察者事情发生了改变
    observable.notifyObserver()
}
```

看着观察者模式好像很深奥的样子，其实就是被观察者中有一个观察者的集合，订阅其实就是将观察者添加到这个集合中。

当有新消息的时候，被观察者遍历观察者集合，然后调用他们的方法即可。

## RxJava中的观察者模式

RxJava中的观察者模式更简单，上面所说的可能会出现一堆的观察者，而RxJava模式中的观察者与被观察者是一对一的。怎么样，是不是更进一步降低了难度？

为了更好地理解事件驱动，我们可以用上游和下游来代替被观察者和观察者。

什么是上游和下游？

简单的来讲就是两个水管，这两个水管以一定的方式连接了起来，水管里的水从上面的水管流到了下面的水管。

也就是说上面的水管负责流水，下面的水管负责接水。水就是事件

我们一般是这么使用的

```kotlin
//创建上面的水管
Observable.create<Int> { emitter ->
   	//让水流出去                     
    emitter.onNext(10)
}	//连接两个水管	
	.subscribe (
     //创建下面的水管   
     { item ->   
      	//上面的水流下来了，打印出来
    	println(item)
     }
)
```

这是一般的使用方式，即创建一个上游，然后上游发送事件，下游去接收。

