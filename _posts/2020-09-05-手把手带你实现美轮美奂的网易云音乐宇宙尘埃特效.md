---
layout:     post
title:      手把手带你实现美轮美奂的网易云音乐宇宙尘埃特效
subtitle:   0202年了，自定义View还不会？让我带你搞定吧
date:       2020-09-2
author:     MLX
header-img: img/customView.jpg
catalog: 	 true
tags:
    - Android
    - Binder
    - IPC
typora-root-url: ..



---

## 前言

0202年了，Android开发大都应该是老油条了把。如果你自定义View还是掌握得不够熟练的话，那可就说不过去了哦。自定义View可以说是Android开发中，无论是初级，中级还是高级都必须掌握的一个点。

不然的话，UI一不小心设计的太炫酷，那你岂不是要和他打起来了？难道你不想成为下图中的男人吗？

![](/img/emoji/UI程序员打架.jpg)

所以，自定义View的重要性已经不用我多说了。本篇是针对有自定义View基础知识，但是苦于没有好的项目模仿，或者说看到了酷炫效果没有思路不知道该如何下手的人。恭喜你，我将一步步的先分析效果，在代码实现。

我就知道没图是骗不到人的。先放图，大家看一下最终实现的效果。

ps：为了能更快加载出来，gif是压缩了又压缩，流畅性大家可以脑部清晰度。

ps2：小伙伴如果有好的gif压缩网站可以推荐一波

![](/img/cross.gif)

咳咳，虽然画质堪比AV画质，但是还是能看的出来效果是非常不错的。那么今天我就带小伙伴们一起从头到尾的实现一下这个效果吧。

<img src="/img/emoji/出发.jpg" style="zoom:50%;" />

## 特效分析

首先看动图，我们可以拆成两部分完成，一个是里面不断旋转的圆形图片，一个是外面不断扩散的粒子动效。

我们由易到难来完成，毕竟柿子要挑软的捏嘛。

另外由于本篇重点是讲自定义View的，所以就不采用ViewGroup的方式来实现图片和粒子动效的结合了。而是采用分开布局的方式。这样做的好处是可以只专注于粒子动效的实现，而不需要去考虑测量，布局等。

至于自定义ViewGroup，下一篇文章我将会带领大家实现一个非常非常非常酷炫的效果。

## 加载图片

我们先观察，首先这是一个圆形图片。其次，它在不停的转。

![](/img/emoji/废话.jpg)

咳咳，先别骂，容我说完嘛。

圆形图片的话我们就用Glide来进行实现把，其实自定义View实现也可以，但我们重点还是粒子特效。

首先定义一个ImageView

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/rootLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true">

	<ImageView
            android:id="@+id/music_avatar"        
            android:layout_centerInParent="true"
            android:layout_width="178dp"
        	android:layout_height="178dp"/>

</RelativeLayout>
```

现在我们去Activity中，用Glide加载一张圆形图片。

```kotlin
class DemoActivity : AppCompatActivity() {

    private lateinit var demoBinding: ActivityDemoBinding
    
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        demoBinding = ActivityDemoBinding.inflate(layoutInflater)
        setContentView(demoBinding.root)
		
        lifecycleScope.launch(Dispatchers.Main) {
           loadImage()
        }
    }
    private suspend fun loadImage() {
        withContext(Dispatchers.IO) {
            Glide.with(this@DemoActivity)
                    .load(R.drawable.ic_music)
                    .circleCrop()
                    .into(object : ImageViewTarget<Drawable>(demoBinding.musicAvatar) {
                        override fun setResource(resource: Drawable?) {     
                            demoBinding.musicAvatar.setImageDrawable(resource)
                        }
                    })
        }
    }
}
```

这样我们利用Glide就加载了一个圆形的图片。



## 旋转图片

图片有了，接下来就应该是旋转了。

那么我们开始搞旋转。

旋转是如何实现的？我想不用我多说，很多小伙伴都知道，是动画嘛。

没错，就是动画。我们这里使用属性动画来实现。

定义一个属性动画并且给图片设置一个点击事件，让它旋转起来

```kotlin
lateinit var rotateAnimator: ObjectAnimator

override fun onCreate(savedInstanceState: Bundle?) {
    	...
    	setContentView(demoBinding.root)
 		rotateAnimator = ObjectAnimator.ofFloat(demoBinding.musicAvatar, View.ROTATION, 0f, 360f)
        rotateAnimator.duration = 6000
        rotateAnimator.repeatCount = -1
        rotateAnimator.interpolator = LinearInterpolator()
   		lifecycleScope.launch(Dispatchers.Main) {
            loadImage()
            //添加点击事件，并且启动动画
            demoBinding.musicAvatar.setOnClickListener {
                rotateAnimator.start()
            }
        }
}
```

这些都是小儿科了，相信面对电视机前的观众朋友们，啊不，口误口误。

相信小伙伴们都很熟悉了，那我们开始今天的重头戏，这个粒子动画。

## 粒子动画

其实我很久以前看粒子动画的时候，也很好奇，这些炫酷的粒子动画是怎么实现的，当时的我完全没有思路。

尤其是看到一些图片，啪唧一下变成了一堆粒子，掉落，然后又呱唧从粒子变成了图片，就觉得异常的牛X。

其实啊，一点都不神奇。

首先我们要知道bitmap是什么。bitmap是什么呀？

在数学上，有这么几个概念，点，线，面。点很好理解，就是一个点。线是由一堆点组成的，而面又类似于一堆线组成的。本质上，面就是由无数的点组成的。

可是这和bitmap以及今天的粒子动画有什么关系呢？

一个bitmap，我们可以简单地理解为一张图片。这个图片是不是一个平面呢？而平面又是一堆点组成的，这个点在这里称为像素点。所以bitmap就是由一堆像素点所组成的，有趣的是，这些像素点是有颜色的，当这些像素点足够小，你离得足够远你看起来就像一幅完整的画了。

在现实中也不乏这样的例子，举办一些活动的时候，一个个人穿着不同颜色的衣服有序的站在广场上，如果有一架无人机在空中看，就能看到是一幅画。就像这样

![](/img/人群粒子.jpeg)

所以当把一幅画拆成一堆粒子的话，其实就是获得bitmap中所有的像素点，然后改变他们的位置就可以了。如果想要用一堆粒子拼凑出一幅画，只需要知道这些粒子的顺序，排放整齐自然就是一幅画了。

扯远了，说这些呢其实和今天的效果没有特别强的联系，只是为了让你能够更好的理解粒子动画的本质。

![](/img/emoji/别废话开车.jpg)

### 粒子动画分析

我们先观察这个特效，你会发现有一个圆，这个圆上不断的往外发散粒子，粒子在发散的过程中速度是不相同的。而且，在发散的过程中，透明度也在不断变化，直到最后完全透明。

好，我们归纳一下。

- 圆形生产粒子
- 粒子速度不同，也就是随机。
- 粒子透明度不断降低，直到最后消散。
- 粒子沿着到圆心的反方向扩散。

写自定义View的时候千万不要一上来就开干，而是要逐渐分析，有的时候我们遇到一个复杂的效果，更是要逐帧的分析。

而且我写自定义View的时候有个习惯，就是一点点的实现效果，不会去一次性实现全部的效果。

所以我们第一步，生产粒子。

### 生产粒子

首先，我们可以知道，粒子是有颜色的，但是似乎这个效果粒子只有白色，那就指定粒子颜色为白色了。

然后我们可以得出，粒子是有位置的，位置肯定由x，y组成嘛。然后粒子还有个速度，以及透明度和半径。

#### 定义粒子

我们可以定义一个粒子类：

```kotlin
class Particle(
    var x:Float,//X坐标
    var y:Float,//Y坐标
    var radius:Float,//半径
    var speed:Float,//速度
    var alpha: Int//透明度
)
```

由于我们的这个效果看起来就像是水波一样的涟漪，我给自定义View起名为涟漪，也就是dimple

我们来定义这个自定义View把

#### 定义自定义view

```kotlin
class DimpleView(context: Context?, attrs: AttributeSet?) : View(context, attrs) {
	//定义一个粒子的集合  
    private var particleList = mutableListOf<Particle>()
    //定义画笔
    var paint = Paint()
}
```

一开始就直接圆形生产粒子着实有些难度，我先考虑考虑如何实现生产粒子把。

先上往下不断生产粒子，然后再考虑圆形的事情。

而且生产一堆粒子比较麻烦，我先实现从上到下生产一个粒子。

那么如何生产一个粒子呢？前面也说了，粒子就是个很小的点，所以用canvas的drawCircle就可以。

那我们来吧

```kotlin
override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)
     	paint.color = Color.WHITE
        paint.isAntiAlias = true
		var particle=Particle(0f,0f,2f,2f100)
        canvas.drawCircle(particle.x, particle.y, particle.radius, paint)
}
```

画画嘛，就要在onDraw方法中进行了。我们先new一个Particle，然后画出来。

那我们看一下效果。



