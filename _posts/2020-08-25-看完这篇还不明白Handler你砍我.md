---
layout:     post
title:      看完这篇还不明白Handler你砍我
subtitle:   从简单使用到源码分析，一文搞懂Handler
date:       2020-08-23
author:     MLX
header-img: img/post-bg-2020-08-22.jpg
catalog: 	 true
tags:
    - Android
    - Handler
    - 音视频
typora-root-url: ..

---

## 前言

`Handler`可以说小伙伴们用的非常多了，可以说`Handler`是支撑整个Android系统运行的基础，本质上Android系统都是由事件驱动的。而处理事件的核心就在于`Handler`。接下来我们就从简单的使用，到源码分析让你彻彻底底明白`Handler`的本质。不会再让你发出为什么`Looper.loop`不会堵塞主线程等这类疑惑。

## 简单使用

一般是在主线程中实现一个Handler，然后在子线程中使用它。

```kotlin
class HandlerActivity: AppCompatActivity() {

    private val mHandler = MyHandler()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // 在子线程中通过自定义的 Handler 发消息
        thread {
            mHandler.sendEmptyMessageDelayed(1, 1000)
        }
    }

    // 自定义一个 Handler
    class MyHandler: Handler() {
        override fun handleMessage(msg: Message) {
            Log.i("HandlerActivity", "主线程：handleMessage: ${msg.what}")
        }
    }
}
```

或者有时候需要在子线程中创建运行在主线程中的`Handler`

```kotlin
class HandlerActivity: AppCompatActivity() {
    private var mHandler: Handler? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        thread {
            //获得main looper 运行在主线程
            mHandler = MyHandler(Looper.getMainLooper())
            mHandler!!.sendEmptyMessageDelayed(1, 1000)
        }
    }
 	// 自定义一个 Handler
    class MyHandler(): Handler() {
        override fun handleMessage(msg: Message) {
            Log.i("HandlerActivity", "子线程：handleMessage: ${msg.what}")
        }
    }
}
```

这就是小伙伴们一般常用的两个用法。大家注意到了在第二个用法中出现了一个`Looper.getMainLooper()`，使用它作为参数，即使`MyHandler`是在子线程中定义的，但是它的`handleMessage`方法依然运行在主线程。我们看一下这个参数究竟是什么东东~

```java
public Handler(@NonNull Looper looper) {
        this(looper, null, false);
}
```

可以看到这个`Looper`就是我们上面传入的参数`Looper.getMainLooper()`，也就说明了`handleMessage`方法具体运行在哪个线程是和这个`Looper`息息相关的。那么这个`Looper`究竟是何方神圣，它是怎么做到线程切换的呢？我们先来看一张图

![](/img/android_handler_structure.png)