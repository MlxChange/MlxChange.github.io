---
layout:     post
title:      不懂就砍我之Android启动流程(三)
subtitle:   是兄弟就来砍我，赶紧一起学Android启动流程吧。
date:       2020-09-14
author:     MLX
header-img: img/android_bg.png
catalog: 	 true
tags:
    - Android
    - Binder
    - IPC
typora-root-url: ..

---

## 前言

在前面的篇幅中，我们探索了init进程，zygote进程以及SsystemServer进程。系统启动到这里，就要走到最后的一步，启动主界面，Home程序了。也就是Launcher的启动。但是Home作为一个app，要启动它必须得开启进程，所以我们先学习如何开启进程。

![](/img/emoji/冲.jpg)

## 进程与线程

老规矩，首先要明白什么是进程。而说起进程，又不得不提线程。那么它们究竟是什么，区别又是什么。

计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。假定工厂的电力有限，一次只能供给一个车间使用。

也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。

进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。

一个车间里，可以有很多工人。他们协同完成一个任务。线程就好比车间里的工人。一个进程可以包括多个线程。

车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存

可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫互斥锁（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。

还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做["信号量"](http://en.wikipedia.org/wiki/Semaphore_(programming))（Semaphore），用来保证多个线程不会互相冲突。

当然，这都是假定工厂电力有限的情况，但实际上电力往往是富裕的。所以我们的系统中是多进程，并且每个进程都会有一个或多个线程同时运行的。

## Android中的进程与线程

- 进程：每个`App`在启动前必须先创建一个进程，该进程是由`Zygote` fork出来的，进程具有独立的资源空间，用于承载App上运行的各种Activity/Service等组件。大多数情况一个`App`就运行在一个进程中，除非在AndroidManifest.xml中配置`Android:process`属性，或通过native代码fork进程。
- 线程：线程对应用开发者来说非常熟悉，比如每次`new Thread().start()`都会创建一个新的线程，该线程并没有自己独立的地址空间，而是与其所在进程之间资源共享。从Linux角度来说进程与线程都是一个task_struct结构体，除了是否共享资源外，并没有其他本质的区别。

我们知道在Linux进程的创建都是fork出来的，那么具体是如何做的呢，我们先看一张图

![](/img/start_app_process.jpg)

熟悉Binder的小伙伴应该知道，启动一个Acticity或者Service最终是要通过Binder方式来启动的。而我们的ActivityManagerService是运行在system_server进程的，如果想要开启一个新的进程，必须fork  zygote进程，所以system_server进程需要和zygote进程通信才可以。

上图中，首先存在一个发起进程，这个发起进程可以是app内部，这时就是app进程，也可以是Launcher启动桌面应用，这时就是Launcher所在进程了。然后通过binder方式通知给了system_server，这个时候进入了system_server进程。system_server通过socket方式告诉了zygote，这个时候进入了zygote进程。zygote进程通过socket方式接受到消息以后，fork出来一个新的进程，这个时候就进入了这个新的进程中。

不同于一般的跨进程通信，**system_server进程与zygote进程通信的方式是使用socket方式来进行的**。不知道小伙伴们还记得不记得，之前的文章中zygote进程在创建的时候就已经开起了socket作为服务端，当时没讲，现在我来填坑了。 

Launcher还没讲，所以我们先从system_server进程发起请求开始讲起。也就是说，咱们先不管是谁通知的system_server进程，咱们先看看system_server进程收到通知后会做什么事情吧。

## SystemServer发起请求

调用链如下:

`Process.start()` ---> `ZygoteProcess.start()` ---->`ZygoteProcess.startViaZygote()`

### ZygoteProcess.startViaZygote

```java
//frameworks/base/core/java/android/os/ZygoteProcess.java
private Process.ProcessStartResult startViaZygote(final String processClass,
                                                      final String niceName,
                                                      final int uid, final int gid,
                                                      final int[] gids,
                                                      int runtimeFlags, int mountExternal,
                                                      int targetSdkVersion,
                                                      String seInfo,
                                                      String abi,
                                                      String instructionSet,
                                                      String appDataDir,
                                                      String invokeWith,
                                                      boolean startChildZygote,
                                                      String[] extraArgs)
                                                      throws ZygoteStartFailedEx {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        ...
        argsForZygote.add("--setgid=" + gid);
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
       	...
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
       	....
        synchronized(mLock) {
            return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
        }
    }
```

该过程主要工作是生成`argsForZygote`数组，该数组保存了进程的uid、gid、groups、target-sdk、nice-name等一系列的参数。

### ZygoteProcess.openZygoteSocketIfNeeded

```java
//frameworks/base/core/java/android/os/ZygoteProcess.java
@GuardedBy("mLock")
private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
        Preconditions.checkState(Thread.holdsLock(mLock), "ZygoteProcess lock not held");

        if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
            try {
                //向主zygote发起connect()操作
                primaryZygoteState = ZygoteState.connect(mSocket);
            } catch (IOException ioe) {
                throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
            }
            ...
        }
        if (primaryZygoteState.matches(abi)) {
            return primaryZygoteState;
        }
         //当主zygote没能匹配成功，则采用第二个zygote，发起connect()操作
        if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
            try {
                secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
            } catch (IOException ioe) {
                throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
            }
          ...
        }
        if (secondaryZygoteState.matches(abi)) {
            return secondaryZygoteState;
        }
        throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
    }
```

`openZygoteSocketIfNeeded(abi)`方法是根据当前的abi来选择与zygote还是zygote64来进行通信。`ZygoteState.connect(mSocket)`这个方法简略的看一下

#### ZygoteState.connect()

```java
 //frameworks/base/core/java/android/os/ZygoteProcess.java
 public static ZygoteState connect(LocalSocketAddress address) throws IOException {
            ...
            final LocalSocket zygoteSocket = new LocalSocket();
            try {
                //最终使用的是LocalSocket的connect方法。
                zygoteSocket.connect(address);
              ...
            } catch (IOException ex) {
              ...
            }    
            return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,
                    Arrays.asList(abiListString.split(",")));
        }
```

也就是说，`SystemServer`最终使用了`LocalSocket`来与`Zygote`进程进行socket通信。我们继续回到startViaZygote方法中，此时`openZygoteSocketIfNeeded`方法已经返回了`ZygoteState`对象，那我们来看看zygoteSendArgsAndGetResult方法具体做了什么事情。

### ZygoteProcess.zygoteSendArgsAndGetResult

```java
//frameworks/base/core/java/android/os/ZygoteProcess.java
@GuardedBy("mLock")
    private static Process.ProcessStartResult zygoteSendArgsAndGetResult(
            ZygoteState zygoteState, ArrayList<String> args)
            throws ZygoteStartFailedEx {
        try {
            ...

           	//得到写入buffer
            final BufferedWriter writer = zygoteState.writer;
            final DataInputStream inputStream = zygoteState.inputStream;

            writer.write(Integer.toString(args.size()));
            writer.newLine();
			//循环写入数据
            for (int i = 0; i < sz; i++) {
                String arg = args.get(i);
                writer.write(arg);
                writer.newLine();
            }
            writer.flush();         	
            Process.ProcessStartResult result = new Process.ProcessStartResult();
            //等待socket服务端（即zygote）返回新创建的进程pid;
            result.pid = inputStream.readInt();
            result.usingWrapper = inputStream.readBoolean();

            if (result.pid < 0) {
                throw new ZygoteStartFailedEx("fork() failed");
            }
            return result;
        } catch (IOException ex) {
            zygoteState.close();
            throw new ZygoteStartFailedEx(ex);
        }
    }
```

方法看起来还是很简单的，就是得到了一个写入的buffer缓存，然后不停的发送数据，发送的数据其实就是一个参数列表。然后进入阻塞等待状态，直到远端的socket服务端发送回来新创建的进程pid才返回。那么此时压力就来到了Zygote进程中了。

## Zygote进程接受请求

在前面的文章中我们讲了，zygote是init进程解析`init.zygote64.rc`文件fork来的，而在解析`init.zygote64.rc`文件中就创建了socket，同时，在进入到Java层后，ZygoteInit类又创建socket管道，并进入循环监听状态:

### ZygoteInit.main()

```java
//frameworks/base/core/java/com/android/internal/os/ZygoteInit.java

public static void main(String argv[]) {
    	//创建ZygoteServer，用于Socket的连接服务
        ZygoteServer zygoteServer = new ZygoteServer();
           
        try {  
            zygoteServer.registerServerSocketFromEnv(socketName);
           	...
            //进入循环
            caller = zygoteServer.runSelectLoop(abiList);
        } catch (Throwable ex) {
            throw ex;
        } finally {
            zygoteServer.closeServerSocket();
        }
        if (caller != null) {
            caller.run();
        }
}
```

### ZygoteServer.runSelectLoop

```java
//frameworks/base/core/java/com/android/internal/os/ZygoteServer.java
Runnable runSelectLoop(String abiList) {
        ArrayList<FileDescriptor> fds = new ArrayList<FileDescriptor>();
        ArrayList<ZygoteConnection> peers = new ArrayList<ZygoteConnection>();
		//mServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0]
        fds.add(mServerSocket.getFileDescriptor());
        peers.add(null);

        while (true) {
            StructPollfd[] pollFds = new StructPollfd[fds.size()];
            for (int i = 0; i < pollFds.length; ++i) {
                pollFds[i] = new StructPollfd();
                pollFds[i].fd = fds.get(i);
                pollFds[i].events = (short) POLLIN;
            }
            try {
                //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里
                Os.poll(pollFds, -1);
            } catch (ErrnoException ex) {
                throw new RuntimeException("poll failed", ex);
            }
            for (int i = pollFds.length - 1; i >= 0; --i) {
                 //采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行；
            	// 否则进入continue，跳出本次循环。
                if ((pollFds[i].revents & POLLIN) == 0) {
                    continue;
                }

                if (i == 0) {
                     //即fds[0]，代表的是mServerSocket，则意味着有客户端连接请求；
               		 //则创建ZygoteConnection对象,并添加到fds。
                    ZygoteConnection newPeer = acceptCommandPeer(abiList);
                    peers.add(newPeer);
                    fds.add(newPeer.getFileDesciptor());
                } else {
                    //i>0，则代表通过socket接收来自对端的数据，并执行相应操作
                    try {
                        //注释1
                        ZygoteConnection connection = peers.get(i);
                        //在这个方法中会fork进程，所以之后的代码会同时存在两个进程运行。
                        final Runnable command = connection.processOneCommand(this);

                        if (mIsForkChild) {
                            //此时处于子进程中，返回runnable
                            if (command == null) {
                                throw new IllegalStateException("command == null");
                            }
                            return command;
                        } else {
                           	//如果请求端关闭了链接，则zygote关闭连接，并移除socket
                            if (connection.isClosedByPeer()) {
                                connection.closeSocket();
                                peers.remove(i);
                                fds.remove(i);
                            }
                        }catch (Exception e) {
                        ...
                    } finally {
                        //重置子进程标识符
                        mIsForkChild = false;
                    }
                }
    }
```

