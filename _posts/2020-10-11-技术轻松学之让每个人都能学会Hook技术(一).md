---
layout:     post
title:      妈妈再也不担心我学不会Hook了
subtitle:   轻轻松松入门Hook技术
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - Hook
typora-root-url: ..
---

## 前言

Hook是什么？Hook的翻译是钩子的意思。不过我觉得这种翻译不怎么好，给人云里雾里的感觉。

对于Hook，我更喜欢称呼它为捕获，简单地讲就是捕获原来的逻辑，改成自己的逻辑。

对于Java层面的Hook技术不得不会的就是动态代理和反射了。

在Java层面的Hook，动态代理和反射就是核心技术，如果你掌握了这两个技术，那么你就掌握了Hook技术的原理.

很多小伙伴，包括我，一开始不知道的时候对于Hook总觉得是很神秘，很牛逼，很高大上，我肯定学不会的那种技术。但其实，真的真的无敌简单，起码Java层是这样。Native层的Hook技术需要了解虚拟机的原理，稍微有一点困难。不过也不是大问题。本系列将会从Java的Hook，一路直接到Native层的Hook。

小伙伴们可以按需学习。

老规矩，我们出发吧~

![](/img/emoji/出发.jpg)

## 代理

既然提到了动态代理和反射，我们就从这两个开始学起。我倒要看看有什么能难住我们小猫咪的！

首当其冲的就是代理。

什么是代理？

代理就是代购，女朋友很喜欢韩国的化妆品，可是我也不能因为一盒两盒化妆品就跑到韩国去吧，所以我找个代购去帮我买。对，代理对象也是做这个事情的，它负责做中间人，接收一个目标对象，可以在不修改目标对象代码的前提下增强目标对象。

既然提到了动态代理，那必须先有静态代理。

### 静态代理

我们设想一个场景，就是假设一个人，人要吃饭。代码写出来是这样的：

```java
public interface Person{
  void eat(String food);
}
```

接口就要有实现类

```java
public class PersonImpl implements Humen{ 
    @Override 
    public void eat(String food){ 
        System.out.println("eat " + food); 
    } 
}
```

但是问题来了，如果有一个新的需求说人吃饭前得先做饭才能吃。那怎么办？

很简单，直接eat前面加上一些做饭的逻辑不就好了？

OK，问题又来了，某人今天不想做饭而是向下馆子吃那该怎么办？修改原来的逻辑吗？当然也没问题，不过，明天如果说下馆子吃了饭以后还得付钱才能离开，继续修改逻辑吗？恐怕这不是一个良好的设计。

我们不断的在修改原有逻辑，很容易导致其他调用这个类的程序出错。所以我们需要一种方式，既能够改变了这个类的逻辑，又能够不修改它的代码。意思就是我吃饭前想做啥做啥，只需要吃饭的时候调用原来的类，吃饭后想干啥就干啥。

没错，这就是代理模式的由来。也是现在说的静态代理。同时，为了能够尽量的贴合原来的代码，保持原来代码的程序结构，所以我们需要定义一个类，实现原来代码的接口，并接受一个原来的类。

就像这样：

```java
public class PersonProxy implements Person{ 
    private Person person; 
    public PersonProxy(){ 
        person = new PersonImpl(); 
    } 
    @Override 
    public void eat(String food){ 
        before(); 
        person.eat(food); 
        after(); 
    } 
    private void before(){ 
        System.out.println("吃饭前做的事"); 
    } 
    private void after(){ 
        System.out.println("吃饭后做的事"); 
    } 
}
```

如此一来，我们就能够实现在原有代码不修改的情况下，在原有逻辑前后增加自己的新逻辑了。

并且最关键的是，上面`PersonProxy`和`PersonImpl`都持有的是`Person`接口的引用，调用者根本不需要修改原有代码，实例化的方式变了即可。

静态代理，为我们带来了一定的灵活性，是我们在不改变原来的被代理类的方法的情况下，通过在调用处替换被代理类的实例化语句为代理类的实例化语句的方式，实现了改动少量的代码（只改动了调用处的一行代码），就获得额外动作的功能。

静态代理如此优秀，那么有没有缺点呢？

答案当然是有的。我们试着想一下，每当我有一种新的行为的时候，都需要一个新的代理类，这很麻烦。这还只是一个类，如果说我们业务中有很多的类需要这么做，我们一个一个定义过来根本不可能。所以引申出了动态代理的概念。

### 动态代理

我们接着刚才的说。动态代理涉及到两个类，`java.lang.reflect.Proxy`和`java.lang.reflect.InvocationHandler`。作用先不用管，我们先看动态代理是如何实现的。

```java
public class PersonHandler implements InvocationHandler {
    Object target;  // 被代理的对象，实际的方法执行者

    public PersonHandler(Object target) {
        this.target = target;
    }
    @Override
    //method为目标对象的方法，args是目标对象方法对应的参数
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        before();
        Object result = method.invoke(target, args);  // 调用 target 的 method 方法
        after();
        return result;  // 返回方法的执行结果
    }
    // 调用invoke方法之前执行
    private void before() {
        System.out.println("吃饭前做的事");
    }
    // 调用invoke方法之后执行
    private void after() {
        System.out.println("吃饭后做的事");
    }
}
```

PersonHandler类继承了`InvocationHandler`，这个类的作用就是我们要增强的逻辑类。就是说，我们要对目标类做什么。在invoke方法中我们可以针对目标类做一些羞羞的事情，反正随便你做都可以。这个方法最终会在代理类调用接口的时候调用到。

我们的被代理对象变成了一个object。并且调用方法成了反射的方式调用。如果不了解反射，你就简单理解为调用目标的指定方法。这么做的原因就是不在局限于某一个对象，或者某一个类。就像通知某个人开会，你不再需要啰里啰唆说一大堆了，只需要告诉他时间和地点，这个人就会去开会。这个代理方式也是一样的道理，只需要后续再告诉他哪个对象的哪个方法，method.invoke就会执行。

现在该创建代理对象了。

```java
public static void main(String[] args){ 
    //定义一个目标接口的实现类，也就是目标类
    Person person = new PersonImpl(); 
    //定义一个我们自己的逻辑类，也就是我们要做什么的类
    PersonHandler personProxy = new PersonHandler(humen); 
    /*通过它的静态方法，传入三个参数
    * 第一个参数是classLoader
    * 第二个参数是代理类要实现的接口列表
    * 第三个参数就是我们要增强的逻辑类
    */ 
    Person personProxy = (Person) Proxy.newProxyInstance( 
    	person.getClass().getClassLoader(), 
    	person.getClass().getInterfaces(), 
    	personProxy 
    ); 
    personProxy.eat("大米饭"); 
}
```

`Proxy.newProxyInstance`方法通过传入上述三个参数，就会为我们生成一个代理类，我们只需要将它强转为我们需要的类型，然后调用即可。这样动态代理就实现了。

当然最后一个参数我们也可以使用匿名内部类或者lambda 表达式也是一样没问题的。这就是动态代理了。

当然，动态代理也是有缺陷的，就是被代理的类必须实现接口才可以代理。如果没接口怎么办？岂不是傻眼了？

没错，接下来就是无敌强的**CGLib**动态代理了。

## **CGLib** 代理

CGLib并不是JDK中的方法，而是第三方的类库，实现原理是在运行期间动态的生成字节码，动态生成代理类来实现的。其实就是写了一个新的类去继承了被代理的类

```java
public class PersonInterceptor implements MethodInterceptor {
    /**
     * @param object 表示要进行增强的对象
     * @param method 表示拦截的方法
     * @param objects 数组表示参数列表，基本数据类型需要传入其包装类型，如int-->Integer、long-Long、double-->Double
     * @param methodProxy 表示对方法的代理，invokeSuper方法表示对被代理对象方法的调用
     * @return 执行结果
     * @throws Throwable
     */
    @Override
    public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        before();
        // methodProxy.invokesuper执行的是原始类的方法，method.invoke执行的是子类的方法
        //这是由于实现的方式是继承了目标类，所以需要调用父类的方法
        Object result = methodProxy.invokeSuper(object, objects);   
        after();
        return result;
    }
    // 调用invokeSuper方法之前执行
    private void before() {
        System.out.println("吃饭前做的事");
    }
    // 调用invokeSuper方法之后执行
    private void after() {
        System.out.println("吃饭后做的事");
    }
}
```

调用方式是这样的：

```java
public static void main(String[] args){ 
    PersonInterceptor personInterceptor = new PersonInterceptor(); 
    Person personProxy = personInterceptor.getProxy(PersonImpl.class); 
    personProxy.eat("大米饭"); 
}
```

一样很简单 ，有木有？即使不使用接口信息我们依然能够生成代理类。不过这个需要引入第三方包。

CGLib使用很爽，但是也有缺点，既然它原理是生成子类继承了目标类，那么对于final类或者final方法就无法代理。这也是它的问题所在。

好研究完了代理模式，我们就开始研究反射。

## 反射技术

要真正的理解反射，就不得不去理解JVM是如何加载并且运行一个类的。

你以为我要讲JVM？不不不，我今天并不想长篇大论讲解JVM，因为JVM不是一节课两节课能讲解完的。我们只讲一下JVM是如何将我们编写的类文件加载到内存并运行起来的。后续，我将出一系列课程从Java的Jvm到Android的dalvik 虚拟机，再到ART虚拟机全面覆盖。

同时，本系列是讲Hook的，后期会将Native Hook，到时候也会讲一些JVM的东西。

首先我们需要指定JVM是一个什么东西，JVM就是一个虚拟机，其实就是一个小电脑。它能够运行你写的Java程序。要知道，不管是Windows，Linux还是OS X 都无法直接运行Java程序的，上面相当于又跑了一个小电脑，这个小电脑才能运行Java程序。

所以我们运行Java程序的时候，首先会启动JVM虚拟机。然后我们的代码也就是.java文件会被编译为.class文件。

当我们new一个类或者通过反射加载一个类的时候，虚拟机就会使用ClassLoader对象读取.class文件的内容，通常是创建一个字节数组通过IO的方式读取。然后读取完以后产生一个与加载类相关联的Class对象。

这个Class对象也是一个类，是所有类的类。什么是所有类的类呢？

我问你，如果要区别一个类该如何区别？