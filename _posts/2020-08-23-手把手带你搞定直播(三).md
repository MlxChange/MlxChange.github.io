---
layout:     post
title:      手把手带你搞定直播(三)
subtitle:   FFmpeg从零搭建直播APP
date:       2020-08-23
author:     MLX
header-img: img/post-bg-2020-08-22.jpg
catalog: 	 true
tags:
    - Android
    - FFmpeg
    - 音视频

---

## 前言

上一篇文章中，我们一起学习了音视频的基础知识，这一节我们将开发一个用于播放本地或者网络流的播放器。话不多说开始~

## 流程图

首先从上一节基础知识中已经了解到，视频的封装格式很多，所以我们拿到一个视频以后首先第一步就是解封装，然后拿到了视频流和音频流，这里的视频流和音频流是编码后的格式，我们如果要播放的话就需要解码。解码以后拿到了每一帧的数据就可以播放了。

这是流程图可以更好的理解：

<img src="/img/FFmpeg解封装流程.png" style="zoom:67%;" />

## 架构图

流程图大家都是应该了解了，可是FFmpeg很多小伙伴从来没接触过，根本不知道如果解封装，也不知道如何解码，其实就是一些API的调用，为了方便大家理解，我这里绘制了带API的播放器的架构图。详细的描述了每一步的步骤：

![](/img/ffplayer.png)

可能有的小伙伴看了这个图已经开始骂人了，卧槽这么复杂，学不下去了！再见！

兄dei，莫急，听我慢慢道来。

图看起来确实比较复杂，但是聪明的小伙伴已经能明白其中的意思了。emmm，不明白的也不是说不聪明，可能是没接触过这样的方式。首先左边就是解封装的流程，对应的是流程图中解封装步骤，右边两个分别是视频和音频的解码和播放步骤。细心的小伙伴已经发现了，视频和音频的处理方式几乎是一毛一样的~唯一的不同就是播放方式和视频部分多了一小节。这一小节就是处理音视频同步的，在后面会讲~

我先来给大家分析一下

首先第一步就是先拿到媒体文件，甭管它是本地文件还是网络流，我们要打开它，然后拿到其中的视频流/音频流信息，然后根据它编码方式查找到对应的解码器，设置一些参数balabalabala。最后打开解码器，从视频流/音频流中一帧一帧的读取数据包。由于这是个循环，并且是个耗时操作，我们需要开启一个线程去处理它。

当我们拿到数据包以后，判断它是视频包还是音频包，并把它交给视频类的数据包队列或音频类的数据包队列中去处理可以看到不管是视频类还是音频类都有这个队列。

以视频为例，视频类同样需要开启一个新的线程循环的从队列中读取数据包，然后根据解码器去解码成原始数据。并将原始数据添加到原始数据的的队列中。视频类另外再开启一个渲染的线程，用以循环不断地从原始数据队列中取出原始数据YUV格式的图片，并将YUV格式的图片转换为RGB图像，将其渲染到屏幕上。音视频同步在后面统一讲，这里先不做叙述。

这样讲的话小伙伴们应该大致了解了。下面开始代码走起~

## 解封装

首先定义一个Player的C++类，进行一个初始化解码器的操作。

```c++
void MlxPlayer::_prepare() {
    //AVDictionary是一个健值对存储工具，类似于c++中的map
    AVDictionary *dictionary = 0;
    //设置读取超时
    av_dict_set(&dictionary, "timeout", "10000000", 0);
    //打开媒体文件，这里的dataSource就是Kotlin传来的本地文件地址或者网络地址，formatContext是全局的上下文参数，如果比喻的话可以类比Activity中的Context
    int openStatus = avformat_open_input(&formatContext, this->dataSource, 0, &dictionary);
    //如果打开状态失败就回调Koltin接口，提示失败信息
    if (openStatus) {
        this->javaCallBack->onPerpareFaild(THREAD_CHILD, openStatus);
        return;
    }
    //通过全局上下文参数获取媒体文件中的流信息
    int findStreamCode = avformat_find_stream_info(formatContext, 0);
    //如果没有找到流信息，依然回调Kotlin失败接口
    if (findStreamCode) {
        this->javaCallBack->onPerpareFaild(THREAD_CHILD, findStreamCode);
        return;
    }
	//里面可能不止一个流信息，可能有视频流，音频流，甚至是字幕流。所以遍历所有的流
    for (int i = 0; i < formatContext->nb_streams; ++i) {
        //获取流
        AVStream *avStream = formatContext->streams[i];
        //获取流的编码参数
        AVCodecParameters *parameters = avStream->codecpar;
        //通过id查找解码器
        AVCodec *avCodec = avcodec_find_decoder(parameters->codec_id);
        //创建解码器上下文
        AVCodecContext *codecContext = avcodec_alloc_context3(avCodec);
        //设置编码参数
        avcodec_parameters_to_context(codecContext, parameters);
        //打开解码器
        int ret = avcodec_open2(codecContext, avCodec, 0);
        //失败则回调
        if (ret) {
            this->javaCallBack->onPerpareFaild(THREAD_CHILD, -12);
            return;
        }
        //如果是视频，则创建视频类，否则是音频类。并传递流的索引和解码器上下文
        if (parameters->codec_type == AVMEDIA_TYPE_VIDEO) {
            videoChannle = new VideoChannle(i, codecContext);
        } else if (parameters->codec_type == AVMEDIA_TYPE_AUDIO) {
            audioChannle = new AudioChannle(i, codecContext);
        }
    }
    //如果这里都没有的话代表既没有视频也没有音频，回调失败接口
    if (!audioChannle && !videoChannle) {
        this->javaCallBack->onPerpareFaild(THREAD_CHILD, -10);
        return;
    }
    //回调成功接口，表示下一步可以开始解码并播放了。
    this->javaCallBack->onPerpareSuccess(THREAD_CHILD);
}
```

`javaCallBack`是一个回调的类，主要负责C++调用Java/Kotlin,并将各种结果传递给上层。

其他的说明在上述的注释里已经讲得很详细了。

## 从流中读取数据包

```c++
void MlxPlayer::_start() {   
    //定义一个入参AVPacket，用于接收数据包
    AVPacket *packet;
    //循环读取
    while (isPlaying) {
        if(!isPlaying){
            break;
        }
        if (videoChannle && videoChannle->packets.size() > 20) {
            av_usleep(20 * 1000);
            continue;
        }
        if (audioChannle && audioChannle->packets.size() > 20) {
            av_usleep(20 * 1000);
            continue;
        }
        if(!isPlaying){
            break;
        }
        //申请内存
        packet = av_packet_alloc();
        //锁定当前线程
        pthread_mutex_lock(&mutex);
        //读取一个数据包
        int ret = av_read_frame(formatContext, packet);
        //解锁当前线程
        pthread_mutex_unlock(&mutex);
        //如果读取到了，看源代码的话，可以了解到如果成功了，ret就是0，否则就是其他数值。
        if (!ret) {
            //如果存在video类，并且包的流索引于视频索引一样就代表是视频包，则将其添加到视频队列中，下面音频同理
            if (videoChannle && packet->stream_index == videoChannle->id) {
                videoChannle->packets.push(packet);
            } else if (audioChannle && packet->stream_index == audioChannle->id) {
                audioChannle->packets.push(packet);
            }
            
        } else if (ret == AVERROR_EOF) {//这里是读取到了文件末尾
            //如果视频/音频中数据包和原始数据包的队列都为空了，那么我们认为是播放结束了。
            if (videoChannle->packets.empty() && videoChannle->frames.empty()
                && audioChannle->packets.empty() && audioChannle->frames.empty()) {
                //停止播放并且回调播放结束的接口
                isPlaying = 0;
                if (javaCallBack) {
                    this->javaCallBack->onPlayEnd();
                }
                break;
            }
        } else {//其他错误的话就回调错误接口即可
            if (javaCallBack) {
                this->javaCallBack->onPerpareFaild(THREAD_CHILD, ret);
            }
            isPlaying = 0;
            break;
        }
    }
    //最后释放这个包所占用的内存空间
    av_packet_free(&packet);
}
```

该有的注释上面基本都有了，需要说明的是上面出现了两次`isPlaying`为空的判定，这是因为`av_usleep(20 * 1000);`是一个线程休眠的方法，在这段休眠过程中很可能其他线程操作了`isPlaying`已经停止播放了，所以需要进行二次判定。理论上来说所有的耗时方法结束以后都应该进行一次判定，但是后面有其他方式去解决这个问题。

还有一点就是下面的这段代码：

```c++
if (videoChannle && videoChannle->packets.size() > 20) {
         av_usleep(20 * 1000);
         continue;
}
if (audioChannle && audioChannle->packets.size() > 20) {
        av_usleep(20 * 1000);
        continue;
}
```

其实这个也很好理解，就是控制队列中的数据容量的，有可能播放很慢，但是读取数据很快，导致队列中的数据越攒越多，出现内存泄漏的问题。就是一个消费者生产者得问题，消费很慢，生产很快。这里就控制不让生产，先消费一段时间，再继续恢复生产。

## 视频解码