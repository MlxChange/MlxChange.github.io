---
layout:     post
title:      Java并发编程基础(一)
subtitle:   从基础概念到实践探索一步步理解并发
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - Hook
typora-root-url: ..

---

## 前言

在Java程序中，有很多高深的技术，一种并发就是一门很需要研究和琢磨的技术。倒不是说创建一个线程有多难，难点在于多线程的同步以及如何处理线程安全的问题。

既然是并发编程，我们就需要先理解一些概念才能够更加深入的去学习。

![](/img/emoji/出发.jpg)

## 线程与进程

**先给一个学院派的具体回答：进程是资源分配的最小单位，线程是CPU调度的最小单位**

**进程是资源分配的最小单位**

什么是资源呢，就是内存，文件，socket等，比如你new了一块内存，就是操作系统将一块物理内存映射到你的进程地址空间上，这块内存就是属于你这个进程的，你进程内的所有线程都可以访问这块内存，其他进程就访问不了。其他类型的资源也是同理。所以进程是分配资源的基本单位（而不是线程，因为同一个进程内的所有线程都可以访问这些资源）

任务的执行需要依赖各个PC资源，我们可以称为计算机执行的上下文环境。要实现“同时执行”，就需要不断轮换，为了后来继续从当前状态执行下去，计算机需要保存切换前的程序上下文。所以有了进程：用进程去描述程序当前上下文的状态信息----内存位置、变量值、任务ID……

**线程是CPU调度的最小单位，也是作为独立运行和独立调度的基本单位**

**线程**是进程的一个实体，是**独立运行和独立调度**的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)。多个线程共享同一进程内的资源，使用相同的地址空间。一个进程可以包含若干个线程。

简单的说：

- 进程是资源的容器，包含（一个或）多个线程。
- 内核调度的基本单位是线程、而非进程。
- 同一进程下的各个线程共享资源（address space、open files、signal handlers，etc），但寄存器、栈、PC等不共享

### 线程与进程的优劣

linux下fork的叫进程，pthread叫线程。

**在Linux中，无论是进程还是线程，根本上都是通过clone一个已存在task（进程|线程）实现的**

- **创建、终止、切换thread的开销要比process小的多**
- **由于共享地址空间，线程通信比进程通信高效得多**

借用知乎上的一张图来表示

![](/img/并发/进程线程模型.jpg)

知道了线程与进程的区别以后，我们来探讨一下什么是并发，什么是并行

## 并发与并行

并发：交替做不同事的能力。简单的说就是一个CPU交替执行程序
并行：同时做不同事的能力。多个CPU一起执行执行。

**只有当CPU至少有两个核心的时候才有可能并行，而能不能并发与CPU的核心数无关，单核CPU也可以实现并发**

看知乎上一个老哥用一句话很形象的形容了并行与并发：

一皇二后是并发，二皇二后是并行。

## 为什么要用多线程

使用多线程最主要的原因是**提高系统的资源利用率**。也就是我们平常说的能够**加快程序运行的速度啊**。现在CPU基本都是多核的，如果你只用单线程，那就是只用到了一个核心，其他的核心就相当于空闲在那里了。

那么问题来了，对于单核是不是就没有必要使用多线程了呢？答案也不是

对于单核，最常用到多线程的地方就是网络和IO。为什么呢

众所周知IO操作相对于CPU而言是非常慢的，CPU等待IO那段时间是空闲的。如果我们需要做类似IO这种慢的操作，可以开多个线程出来，尽量不要让CPU空闲下来，提高系统的资源利用率

![](/img/并发/压榨CPU.jpg)

那么是不是多线程就是一定好呢？

**多线程不是银弹，并不是说线程越多，我们的资源利用效率就越好**。执行IO操作我们线程可以适当多一点，因为很多时候CPU是相对空闲的。如果是计算型的操作，本来CPU就不空闲了，还开很多的线程就不对了（有多线程就会有线程切换的问题，线程切换都是需要耗费资源的，有时候线程切换的时间甚至比你代码执行的时间都要长）

## 在Java中使用线程

Java是支持多线程的，在Oracle的官网中，明确写了开启一个新线程的方法有两种

### 开启线程的两种方法

方法一：实现Runnable接口，重写run()函数，运行start()方法

```java
public class HelloRunnable implements Runnable {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }

}
```

方法二：继承Thread类，重写run()函数，运行start()方法

```java
public class HelloThread extends Thread {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new HelloThread()).start();
    }

}
```



### 关于启动线程的一些错误观点

- 线程池创建线程也算是一种新建线程的方式
- 通过Callable和FutureTask创建线程，也算是一种新建线程的方式。无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式
- 定时器
- 匿名内部类

上面这些观点都是错的。启动线程的方式只有两种继承thread/实现runnable接口。但是实现runnable接口后，仍然需要调用thread.run。所以严格的来讲**只有一种创建线程方式、两种实现执行单元的方式**

那么为什么上面的观点是错的呢？

因为线程池源码中最后也是new了一个Thread。Callable方式最终也是实现了runnable接口。定时器也是实现了runnable接口。其它的匿名内部类或者lambda表达式都是一样道理。

### 两种启动方法的区别

首先看看Thread的run方法

```java
public void run() {
   if (runnable != null) {
      runnable.run();
   }
}
```

runnable就是我们传入的runnable接口的实现类。

所以Thread的run方法如果有runnable接口就执行runnable的run方法，如果没有就执行自己的逻辑。

这就应证了本质上只有一种创建线程方式这句话。执行的方式不同而已。

我们应该选择哪个方式呢？

实现Runnable接口的方式更好。这是原因

- 实现线程与任务的分离，即我们只需要定义任务，至于交给哪个线程执行由其他策略来具体选择。
- Java不允许多继承，所以我们一旦继承了Thread类，就无法在继承别的类了。

那如果我都写了，代码会如何运行呢？

其实很简单，你都写了的话会执行继承Thread的类中的run方法，因为你重写了这个类的run方法，原本的方法便不会被执行。

### 启动线程的正确方法

启动线程的正确方式就是调用Thread的start方法。

为什么不能调用runnable的run方法呢？因为它本质上是个普通方法，你调用了并没有达到开启线程的目的。

start方法具体做了哪些事情呢？

1. 启动新线程检查线程状态
2. 加入线程组
3. 调用startImpl方法，这是个本地方法。

能否调用两次start方法呢？答案是不能

**在start方法中会判断，如果当前线程已经启动了，再启动会抛出异常。**

### 停止线程的正确方法

错误方法1：被弃用的stop、suspend和resume方法。这三个方法已经被明确弃用了。stop方法是一种“恶意”的中断，一旦执行stop方法，即终止当前正在运行的线程，不 管线程逻辑是否完整，这是非常危险的。也就是说stop方法会破坏原子逻辑

错误方法2：用volatile设置boolean标记位来停止。这种方法在考虑到线程有阻塞的情况下是无法正确中断线程的。

#### 正确方法

**用interrupt来请求停止线程**。**想停止线程，要请求方、被停止方、子方法被调用方相互配合**

interrupt方法的原理：调用Native层代码，标记了标志位，并且根据是否有阻塞状态进行唤醒。

有三个方法可以判断线程是否处于中断状态

- Thread.interrupted，这个方法检查当前线程是否处于中断状态，并且会清除中断标记
- interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)
- isInterrupted()仅仅返回中断标记。

### 如何处理一个不可中断的阻塞呢？

如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程。 但是对于不能响应 InterruptedException 的阻塞，**很遗憾，并没有一个通用的 解决方案。** 但是我们可以利用特定的其它的可以响应中断的方法，**比如:ReentrantLock.lockInterruptibly()，比如:关闭套接字使线程立即返回等方法 来达到目的**

## 线程的几种状态

一张图来概括说明线程的6个状态

![](/img/并发/线程的6个状态.png)

![](/img/并发/线程状态说明.webp)

一般习惯而言，把Blocked(被阻塞）、Waiting(等待）、Timed_waiting(计时等待）都称为阻塞状态

## 线程中的几种重要的方法：

Object中与线程相关方法

| 方法名称                  | 方法说明                               |
| ------------------------- | -------------------------------------- |
| wait()/wait(long timeout) | 获取到锁的线程进入阻塞状态             |
| notify()                  | 随机唤醒被wait()的一个线程             |
| notifyAll();              | 唤醒被wait()的所有线程，重新争抢时间片 |

Thread类中的核心方法

| 方法名称          | 是否static | 方法说明                                                     |
| ----------------- | ---------- | ------------------------------------------------------------ |
| start()           | 否         | 让线程启动，进入就绪状态,等待cpu分配时间片                   |
| run()             | 否         | 重写Runnable接口的方法,线程获取到cpu时间片时执行的具体逻辑   |
| yield()           | 是         | 线程的礼让，使得获取到cpu时间片的线程进入就绪状态，重新争抢时间片 |
| sleep(time)       | 是         | 线程休眠固定时间，进入阻塞状态，休眠时间完成后重新争抢时间片,休眠可被打断 |
| join()/join(time) | 否         | 调用线程对象的join方法，调用者线程进入阻塞,等待线程对象执行完或者到达指定时间才恢复，重新争抢时间片。本质上仍然是wait |
| isInterrupted()   | 否         | 获取线程的打断标记，true:被打断，false：没有被打断。调用后不会修改打断标记 |
| interrupt()       | 否         | 打断线程，抛出InterruptedException异常的方法均可被打断，但是打断后不会修改打断标记，正常执行的线程被打断后会修改打断标记 |
| interrupted()     | 否         | 获取线程的打断标记。调用后会清空打断标记                     |
| stop()            | 否         | 停止线程运行 不推荐                                          |
| suspend()         | 否         | 挂起线程 不推荐                                              |
| resume()          | 否         | 恢复线程运行 不推荐                                          |
| currentThread()   | 是         | 获取当前线程                                                 |

### wait直到以下4种情况之一发生时，才会被唤醒：

- 另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；
- 另一个线程调用这个对象的notifyAll()方法；
- 过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；
- 线程自身调用了interrupt()。

### notify唤醒

- notify方法只应该被拥有该对象的monitor的线程调用
- 一旦线程被唤醒，线程便会从对象的“等待线程集合”中被移除，所以可以重新参与到线程调度当中
- 要等刚才执行notify的线程退出被synchronized保护的代码并释放monitor

### wait/notify底层原理

wait方法会将当前线程放入wait set等待被唤醒



1.将当前线程封装成objectwaiter对象node
2.通过objectmonitor::addwaiter方法将node添加到_WaitSet列表中
3.通过ObjectMonitor:exit方法释放当前的ObjectMonitor对象，这样其他竞争线程就可以获取该ObjectMonitor对象
4.最终底层的park方法会挂起线程
notiry方法就是随机唤醒等待池中的一个线程

## 为什么wait() 需要在同步代码块内使用，而 sleep() 不需要

主要是为了通信的可靠，防止死锁等情况的发生。因为很有可能有这种情况

A线程wait前，B线程的notify就全部执行完毕了，A线程就会陷入永久执行的状态。

Sleep为什么可以呢？是因为Sleep是针对当前线程的，和其他线程的关系并不大。并不需要同步操作。

## 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

wait(), notify()和notifyAll()是锁级别的操作，而Java中锁是属于某一个对象的。所以是针对锁进行的操作。而且一个线程可能持有多把锁，如果定义在线程就无法进行多种锁的操作了。

## 如果调用thread对象的wait会怎么样呢？

thread对象在运行完毕后会自动执行notifyAll()方法，会造成我们不可预期的结果，所以不建议使用thread对象进行锁。

### notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？

会继续等待线程执行完，然后继续抢夺锁。此时线程处于BLOCKED状态。

## wait和Sleep的区别

sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。

sleep和wait的区别有： 

1，这两个方法来自不同的类分别是Thread和Object  

2，最主要是sleep方法**没有释放锁**，而wait方法**释放了锁**，使得敏感词线程可以使用同步控制块或者方法。 

 3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在    任何地方使用 

4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

他们都会释放CPU资源和响应中断

## join方法

因为新的线程加入了我们，所以我们要等他执行完再出发。注意是谁等谁的问题。mainThread中调用t1.join的话是main等待t1.

是main进入wait状态。

join方法也会相应中断，在join方法期间，线程是wait状态。

join的原理还是调用了wait方法，因为是thread的wait方法，在thread执行完之后会自动调用notifyAll方法

## yield方法

作用是释放我的CPU时间片。但是JVM不保证遵循。

yield和sleep区别：是否随时可能再次被调度。

## 守护线程

线程类型默认继承自父线程。守护线程一般是被系统启动的。比如GC所处的线程。

守护线程和普通线程的区别

整体无区别，唯一区别在于是否会影响JVM的离开。如果有非守护线程，JVM不会离开的。

### 线程优先级

线程优先级有十个级别，默认是5.程序设计不应该依赖于线程优先级，因为不同操作系统不一样，优先级也有可能被操作系统改变。

## Java异常体系

 Java把异常作为一种类，当做对象来处理。所有异常类的基类是Throwable类，两大子类分别是Error和Exception。

系统错误由Java虚拟机抛出，用Error类表示。Error类描述的是内部系统错误，例如Java虚拟机崩溃。这种情况仅凭程序自身是无法处理的，在程序中也不会对Error异常进行捕捉和抛出

异常（Exception）又分为RuntimeException(运行时异常)和CheckedException(检查时异常)，两者区别如下：

- RuntimeException：程序运行过程中才可能发生的异常。一般为代码的逻辑错误。例如：类型错误转换，数组下标访问越界，空指针异常、找不到指定类等等。些异常是不检查异常，程序中可以选择捕获处理，也可以不处理
- CheckedException：编译期间可以检查到的异常，必须显式的进行处理（捕获或者抛出到上一层）。例如：IOException, FileNotFoundException等等。若是父类的方法没有声明异常，则子类继承方法后，也不能声明异常。

## run方法中的异常处理

run方法本身定义是没有抛出异常的。所以无法再次往上抛出异常，只能捕获处理。但是如果如果出现RuntimeException的话，JVM是按照如下方式处理的：

- 首先看当前的线程，是否在start之前，通过调用setUncaughtExceptionHandler(UncaughtExceptionHandler, eh)，设置了UncaughtExceptionHandler；如果已经设置，则使用此ExceptionHandler来处理；
- 否则，查看当前Thread所在的ThreadGroup，是否设置了UncaughtExceptionHandler；如果已经设置，则使用此ExceptionHandler来处理；
- 否则，查看Thread层面是否设置了UncaughtExceptionHandler，Thread类的静态方法setDefaultUncaughtExceptionHandler进行设置；如果已经设置，则使用此ExceptionHandler来处理；
- 如果上述UncaughtExceptionHandler都没有找到，那么JVM会直接在console中打印Exception的StackTrace信息。线程此时的状态时停止状态。

全局处理异常的话就是使用Thread的UncaughtExceptionHandler。单独给某个线程的话，就是使用这个线程的UncaughtExceptionHandler。

## Java内存模型

如下是JVM的内存结构

![](/img/并发/JVM内存结构.png)

- 堆区（所有线程共享）：存储的全部是对象实例（通过new等指令创建的，并会被垃圾回收；数组也是保存在堆上面的，即使是基本类型的数据，也是保存在堆中的。因为在Java中，数组是对象），是内存中最大的一块。堆的优势是可以在运行时动态地分配内存空间，不必事先告诉编译器。
- 栈区（每个线程私有）: 每个线程包含一个栈区，栈中保存基础数据类型（byte，short，int，long，float，double，boolean，char）的对象、自定义对象的引用(不是对象本身)和returnAddress（指向了一条字节码指令的地址）。每个方法从被调用到执行完的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。每个栈中的数据(基本类型的局部变量、参数、对象引用)都是私有的，其他栈不能访问。在编译期间就确定了大小，运行期间不会改变大小。
- 方法区（所有线程共享）: 它用于存储虚拟机已经加载的static静态变量、类信息、常量。还存放永久引用，比如static People p = new People();的p引用。运行时常量池:是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分内容将在类加载后放到方法区的运行时常量池中。存放final修饰的。
- 本地方法栈（每个线程私有）: 与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈则是为Native方法服务。
- 程序计数器（每个线程私有）: 是最小的一块内存区域，它的作用是当前线程所执行的字节码的行号指示器，在虚拟机的模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、异常处理、线程恢复等基础功能都需要依赖计数器完成。



### 什么是JMM

Java Memory Model简称JMM。是一组规范，需要各个JVM的实现来遵守JMM规范，以便于开发者可以利用这些规范，更方便地开发多线程程序。

为什么需要内存模型？

C语言不存在内存模型的概念。依赖处理器，不同处理器结果不一样。无法保证并发安全，所以需要一个标准，让多线程运行的结果可预期。如果没有这样的一个JMM内存模型来规范，那么很可能经过了不同JVM的不同规则的重排序之后，导致不同的虚拟机上运行的结果不一样，那是很大的问题。

JMM是工具类和关键字的原理.volatile、synchronized、Lock等的原理都是JMM. 如果没有JMM，那就需要我们自己指定什么时候用内存栅栏(也叫内存屏障)等，那是相当麻烦的，幸好有了JMM，让我们只需要用同步工具和关键字就可以开发并发程序。

JMM最重要的3点内容

- 重排序
- 内存可见性
- 原子性

### 重排序

重排序的现象是实际执行顺序和代码在java文件中的顺序不一致。

#### 重排序分为三种情况：

- 编译器优化：Java运行时环境的JIT编译器也会做指令重排序操作4，即生成的机器指令与字节码指令顺序不一致。
- 指令重排序：CPU 的优化行为，和编译器优化很类似，是通过乱序执行的技术，来提高执行效率。所以就算编译器不发生重排，CPU 也可能对指令进行重排，所以我们开发中，一定要考虑到重排序带来的后果。
- 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。但是内存系统中不是重排序，只是可见性的问题

#### 为什么有重排序呢？

在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。

#### 重排序的原则

As-if-serial语义的意思是，所有的动作(Action)都可以为了优化而被重排序，但是必须保证它们重排序后的结果和程序代码本身的应有结果是一致的。Java编译器、运行时和处理器都会保证单线程下的as-if-serial语义。 比如，为了保证这一语义，重排序不会发生在有数据依赖的操作之中。**如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性**

### 可见性

JVM实现会带来不同的“翻译”，不同的CPU平台的机器指令又千差万别，无法保证并发安全的效果一致。

1. 最开始，我们编写的Java代码，是*.java文件
2. 在编译（javac命令）后，从刚才的*.java文件会变出一个新的Java字节码文件（*.class）
3. JVM会执行刚才生成的字节码文件（*.class），并把字节码文件转化为机器指令
4. 机器指令可以直接在CPU上执运行，也就是最终的程序执行

如下是CPU的缓存结构

![](/img/并发/CPU缓存结构.png)

从上往下，缓存越来越大，速度越来越小。核心之剑的缓存无法互相读取这就是可见性的根本原因。

CPU之所以使用缓存的原因是，因为有很多数据都可以使用缓存，能够极大地提升速度。

**线程间的对于共享变量的可见性问题不是直接由多核引起的，而是由多缓存引起的。**如果所有个核心都只用一个缓存，那么也就不存在内存可见性问题了。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个过期的值。

什么是主内存和本地内存：Java 作为高级语言，屏蔽了CPU cache等底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了主内存和本地内存的概念。

主内村和本地内存的关系：

1. 所有的变量都存储在主内存中，同时每个线程也有自己独立的工作内存，工作内存中的变量内容是主内存中的拷贝
2. 线程不能直接读写主内存中的变量,而是只能操作自己工作内存中的变量，然后再同步到主内存中
3. 主内存是多个线程共享的，但线程间不共享工作内存,如果线程间需要通信，必须借助主内存中转来完成
4. 所有的共享变量存在于主内存中，每个线程有自己的本地内存，而且线程读写共享数据也是通过本地内存交换的，所以才导致了可见性问题。

![](/img/并发/java可见性.webp)

线程A和线程B之间要完成通信的话，要经历如下两步：

1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；
2. 线程B从主存中读取最新的共享变量

### 原子性

一个操作或者说多个操作要么全成功，要么全失败，不可分割。这就是原子性。

i++不是原子性的。

用synchronized实现原子性

原子操作：

1）除long和double之外的基本类型（int, byte, boolean, short, char, float）的赋值操作。

2）所有引用reference的赋值操作，不管是 32 位的机器还是 64 位的机器

3）java.concurrent.Atomic.* 包中所有类的原子操作

#### long 和 double 的原子性

对于 64 位的值的写入，可以分为两个 32 位的操作进行写入。在32位上的JVM上，long 和 double的操作不是原子的，但是在64位的JVM上是原子的。

实际开发中，商用Java虚拟机中不会出现

#### 原子操作+原子操作!=原子操作

去ATM机两次取钱是两次独立的原子操作，但是期间有可能银行卡被借给女朋友，也就是被其他线程打断并被修改。

## 内存屏障

- 硬件层的内存屏障分为两种：`Load Barrier` 和 `Store Barrier`即读屏障和写屏障。
- 内存屏障有两个作用：

> 1. 阻止屏障两侧的指令重排序；
> 2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。

- 对于Load Barrier来说，在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载数据；
- 对于Store Barrier来说，在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。

## java内存屏障

java的内存屏障通常所谓的四种即`LoadLoad`,`StoreStore`,`LoadStore`,`StoreLoad`实际上也是上述两种的组合，完成一系列的屏障和数据同步功能。

- LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
- StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。
- LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
- StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。***它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能\***

有的处理器的重排序规则较严，无需内存屏障也能很好的工作，Java编译器会在这种情况下不放置内存屏障

## volatile语义中的内存屏障

- volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态：

> 在每个volatile写操作前插入StoreStore屏障，在写操作后插入StoreLoad屏障；
>  在每个volatile读操作前插入LoadLoad屏障，在读操作后插入LoadStore屏障；

- 由于内存屏障的作用，避免了volatile变量和其它指令重排序、线程之间实现了通信，使得volatile表现出了锁的特性。

## final语义中的内存屏障

- 对于final域，编译器和CPU会遵循两个排序规则：

> 1. 新建对象过程中，构造体中对final域的初始化写入和这个对象赋值给其他引用变量，这两个操作不能重排序；（废话嘛）
> 2. 初次读包含final域的对象引用和读取这个final域，这两个操作不能重排序；（晦涩，意思就是先赋值引用，再调用final值）

- 总之上面规则的意思可以这样理解，必需保证一个对象的所有final域被写入完毕后才能引用和读取。这也是内存屏障的起的作用：
- 写final域：在编译器写final域完毕，构造体结束之前，会插入一个StoreStore屏障，保证前面的对final写入对其他线程/CPU可见，并阻止重排序。
- 读final域：在上述规则2中，两步操作不能重排序的机理就是在读final域前插入了LoadLoad屏障。

## happens-before

解决可见性问题的：在时间上，动作A发生在动作B之前，B保证能看见A，这就是happens-before。

**JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证**

如果两个操作不具备happens-before，那么JVM是可以根据需要自由排序的，但是如果具备happens-before（比如新建线程时，run方法里面的语句一定发生在thread.start()之前），那么JVM也不能改变它们之间的顺序。

1. 程序次序规则(单线程规则)：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作；
2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作；
3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作；
6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；

## synchronized

同步锁也叫对象锁，是锁在对象上的，不同的对象就是不同的锁。

该关键字是用于保证线程安全的，是**阻塞式**的解决方案。意味着加了该锁的其他对象如果没有得到锁就会进入阻塞状态。

synchronized不仅防止了一个线程在操作某对象时收到其他线程的干扰，同时还保证了修改好之后，可以立即被其他线程所看到。（因为如果其他线程看不到，那也会有线程安全问题）

让同一个时刻最多只有一个线程能持有对象锁，其他线程在想获取这个对象锁就会被阻塞，不用担心上下文切换的问题。

注意：  **不要理解为一个线程加了锁 ，进入 synchronized代码块中就会一直执行下去。如果时间片切换了，也会执行其他线程，再切换回来会紧接着执行，只是不会执行到有竞争锁的资源，因为当前线程还未释放锁**。

当一个线程执行完synchronized的代码块后 会唤醒正在等待的线程

synchronized实际上使用对象锁保证临界区的**原子性** 临界区的代码是不可分割的 不会因为线程切换所打断

![](/img/并发/synchronized实例.webp)

不管是锁的是什么，其实都是对象的一种。

实例对象和类对象的区别在于，实例对象可以有很多，类对象(XX.Class)在JVM中只有一份，相当于全局的单例锁。

## 对象锁（monitor）机制

```java
public class SynchronizedDemo {
    public static void main(String[] args) {
        synchronized (SynchronizedDemo.class) {
           method();
        } 
    }
    
    private static void method() {
    }
}
```

编译之后，切换到SynchronizedDemo.class的同级目录之后，然后用**javap -v SynchronizedDemo.class**查看字节码文件：

![](/img/并发/同步字节码.webp)

用黄色高亮的部分就是需要注意的部分了，这也是添Synchronized关键字之后独有的。执行同步代码块后首先要先执行**monitorenter**指令，退出的时候**monitorexit**指令。通过分析之后可以看出，使用Synchronized进行同步，其关键就是必须要对对象的监视器monitor进行获取，当线程获取monitor后才能继续往下执行，否则就只能等待。而这个获取的过程是**互斥**的，即同一时刻只有一个线程能够获取到monitor。

**锁的重入性**，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized先天具有重入性。**每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一**。

任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到BLOCKED状态。

## volatile

volatile是一种同步机制，比synchronized或者Lock相关类更轻量，因为使用volatile并不会发生上下文切换等开销很大的行为。

如果一个变量别修饰成volatile，那么JVM就知道了这个变量可能会被并发修改。但是开销小，相应的能力也小，虽然说volatile是用来同步的保证线程安全的，但是volatile做不到synchronized那样的原子保护，volatile仅在很有限的场景下才能发挥作用。

#### volatile的作用：

第一层：可见性。读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个 volatile 属性会立即刷入到主内存。通过内存屏障实现的。

第二层：禁止指令重排序优化。解决单例双重锁乱序问题

#### volatile通过内存屏障来实现的

- 写屏障

会在对象写操作之后加写屏障，会对写屏障的之前的数据都同步到主存，并且保证写屏障的执行顺序在写屏障之前

- 读屏障

会在对象读操作之前加读屏障，会在读屏障之后的语句都从主存读，并保证读屏障之后的代码执行在读屏障之后

注意： **volatile不能解决原子性，即不能通过该关键字实现线程安全。**

#### volatile的适用场合

不适用组合操作：a++

适用场合1：boolean flag。如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全。比如初始化。

适用场合2：作为刷新之前变量的触发器。用了volatile int x后，可以保证读取x后，之前的所有变量都可见。

#### volatile和synchronized的关系？

volatile在这方面可以看做是轻量版的synchronized：如果一个共享变量自始至终只被各个线程赋值，而没有其他的操作，那么就可以用volatile来代替synchronized或者代替原子变量，因为赋值自身是有原子性的，而volatile又保证了可见性，所以就足以保证线程安全。

#### volatile和synchronized的区别

**使用上的区别**
volatile只能修饰变量，synchronized只能修饰方法和语句块；

**对原子性的保证**
synchronized可以保证原子性，volatile不能保证原子性；

**对可见性的保证**
都可以保证可见性，但实现原理不同，volatile对变量加了lock，synchronized使用monitorEnter和monitorExit；

**对有序性的保证**
都可以保证有序性，但是synchronized并发退化到串行；

**其他**
synchronized引起阻塞；
volatile不会引起阻塞；

## 单例模式中的应用：

#### 1.饿汉式（静态常量）[可用]

```java
public class Singleton1 {
    
    private final static Singleton1 INSTANCE = new Singleton1();

    private Singleton1() {
    }

    public static Singleton1 getInstance() {
        return INSTANCE;
    }
}
```
优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。由JVM来保证

缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。

#### 2、饿汉式（静态代码块）[可用]

```java
public class Singleton2 {
    private final static Singleton2 INSTANCE;

    static {
        INSTANCE = new Singleton2();
    }

    private Singleton2() {
    }

    public static Singleton2 getInstance() {
        return INSTANCE;
    }
}
```
优缺点和上面一样

#### 3.懒汉式(线程不安全)[不可用]

```kotlin
public class Singleton3 {
    private static Singleton3 instance;

    private Singleton3() {

    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            instance = new Singleton3();
        }
        return instance;
    }
}
```
#### 4.懒汉式(线程安全，使用同步方法)

#### 5.双重检查[推荐用]

```java
public class Singleton5 {
    private static volatile  Singleton5 instance;

    private Singleton5() {

    }

    public static Singleton5 getInstance() {
        if (instance == null) {
            synchronized (Singleton5.class) {
                instance = new Singleton5();
            }
        }
        return instance;
    }
}
```
优点：线程安全；延迟加载；效率较高。

为什么要double-check

因为可以保证线程安全和性能问题。首先进来不加锁是因为如果对象存在的话直接拿就可以了，这样不需要每次都加锁。如果没有在加锁。加锁以后，这个时候在判断一次是否为null。因为再加锁前有可能别的线程已经初始化了。单检查是不行的。

为什么要使用volatile 

是因为指令重排造成的。直接原因也就是 **初始化一个对象并使一个引用指向他 这个过程不是原子的**。导致了可能会出现引用指向了对象并未初始化好的那块堆内存，使用volatile修饰对象引用，防止重排序即可解决。

#### 7、静态内部类[推荐用]

```java
public class Singleton7 {
    private Singleton7() {
    }

    private static class SingletonInstance {

        private static final Singleton7 INSTANCE = new Singleton7();
    }

    public static Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}
```
类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

#### 8.枚举[推荐实际生产用

```java
public enum Singleton8 {
    INSTANCE;
}
```
不仅能避免多线程同步问题，还是懒加载，而且还能防止反序列化重新创建新的对象。避免反射攻击

## 线程安全问题

线程安全：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的

数据不安全最主要两个问题

1. 数据争用：数据读写由于同时写，会造成错误数据。

2. 竞争条件：即使不是同时写造成的错误数据，由于顺序原因依然会造成错误，例如在写入前就读取了。

什么情况下会出现线程安全的问题：

- 访问共享的变量或资源，会有并发风险，比如对象的属性、静态变量、共享缓存、数据库等
- 所有依赖时序的操作，即使每一步操作都是线程安全的，还是存在并发问题：
- 不同的数据之间存在捆绑关系的时候
- 我们使用其他类的时候，如果对方没有声明自己是线程安全的，那么大概率会存在并发问题。比如hashmap没有声明自己是并发安全的，所以我们并发调用hashmap的时候会出错

### 为什么多线程会带来性能问题

- 调度：上下文切换

  上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：（1）挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处，（2）在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复，（3）跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程。

  CPU重新缓存，使缓存失效了。

- 协作：内存同步

  为了数据的正确性，同步手段往往会使用禁止编译器优化、使CPU内的缓存失效

何时会导致密集的上下文切换：频繁地竞争锁，或者由于IO读写等原因导致频繁阻塞

# 死锁

发生在并发中。互不相让：当两个（或更多）线程（或进程）相互持有对方所需要的资源，又不主动释放，导致所有人都无法继续前进，导致程序陷入无尽的阻塞，这就是死锁。

### 死锁的4个必要条件

- 互斥条件
- 请求与保持条件
- 不剥夺条件
- 循环等待条件

### 如何定位死锁？

jstack和ThreadMXBean

### 常见修复策略

避免策略：哲学家就餐的换手方案、转账换序方案

检测与恢复策略：一段时间检测是否有死锁，如果有就剥夺某一个资源，来打开死锁

#### 转账换序方案

实际上不在乎获取锁的顺序。通过hashcode来决定获取锁的顺序、冲突时需要“加时赛”

#### 哲学家就餐的换手方案

死锁：每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）

改变一个哲学家拿叉子的顺序（避免策略）

服务员检查（避免策略）

餐票（避免策略）

## 实际工程中如何避免死锁？

- 设置超时时间
- Lock的tryLock(long timeout, TimeUnit unit)
- 多使用并发类而不是自己设计锁
- 尽量降低锁的使用粒度：用不同的锁而不是一个锁
- 给你的线程起个有意义的名字：debug和排查时事半功倍，框架和JDK都遵守这个最佳实践
- 避免锁的嵌套：MustDeadLock类
- 尽量不要几个功能用同一把锁：专锁专用

## 其他活性故障（又叫活跃性问题）

### 活锁

虽然线程并没有阻塞，也始终在运行（所以叫做“活”锁，线程是“活”的），但是程序却得不到进展，因为线程始终重复做同样的事

活锁：在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉

#### 解决活锁问题

以太网的指数退避算法

加入随机因素

### 饥饿

当线程需要某些资源（例如CPU），但是却始终得不到

原因：

线程的优先级设置得过于低，或者有某线程持有锁同时又无限循环从而不释放锁，或者某程序始终占用某文件的写锁

## 手写一个死锁

```kotlin
fun main(args: Array<String>) {
    val lockmutex1=Any()
    val lockmutex2=Any()
    var thread1 = thread{
        synchronized(lockmutex1){
            Thread.sleep(100)
            synchronized(lockmutex2){
                
            }
        }
    }
    var thread2 = thread{
        synchronized(lockmutex2){
            Thread.sleep(100)
            synchronized(lockmutex1){

            }
        }
    }
}
```