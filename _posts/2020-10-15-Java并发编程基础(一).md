---
layout:     post
title:      Java并发编程基础(一)
subtitle:   从基础概念到实践探索一步步理解并发
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - Hook
typora-root-url: ..

---

## 前言

在Java程序中，有很多高深的技术，一种并发就是一门很需要研究和琢磨的技术。倒不是说创建一个线程有多难，难点在于多线程的同步以及如何处理线程安全的问题。

既然是并发编程，我们就需要先理解一些概念才能够更加深入的去学习。

![](/img/emoji/出发.jpg)

## 线程与进程

**先给一个学院派的具体回答：进程是资源分配的最小单位，线程是CPU调度的最小单位**

**进程是资源分配的最小单位**

什么是资源呢，就是内存，文件，socket等，比如你new了一块内存，就是操作系统将一块物理内存映射到你的进程地址空间上，这块内存就是属于你这个进程的，你进程内的所有线程都可以访问这块内存，其他进程就访问不了。其他类型的资源也是同理。所以进程是分配资源的基本单位（而不是线程，因为同一个进程内的所有线程都可以访问这些资源）

任务的执行需要依赖各个PC资源，我们可以称为计算机执行的上下文环境。要实现“同时执行”，就需要不断轮换，为了后来继续从当前状态执行下去，计算机需要保存切换前的程序上下文。所以有了进程：用进程去描述程序当前上下文的状态信息----内存位置、变量值、任务ID……

**线程是CPU调度的最小单位，也是作为独立运行和独立调度的基本单位**

**线程**是进程的一个实体，是**独立运行和独立调度**的基本单位（CPU上真正运行的是线程）。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)。多个线程共享同一进程内的资源，使用相同的地址空间。一个进程可以包含若干个线程。

简单的说：

- 进程是资源的容器，包含（一个或）多个线程。
- 内核调度的基本单位是线程、而非进程。
- 同一进程下的各个线程共享资源（address space、open files、signal handlers，etc），但寄存器、栈、PC等不共享

### 线程与进程的优劣

linux下fork的叫进程，pthread叫线程。

**在Linux中，无论是进程还是线程，根本上都是通过clone一个已存在task（进程|线程）实现的**

- **创建、终止、切换thread的开销要比process小的多**
- **由于共享地址空间，线程通信比进程通信高效得多**

借用知乎上的一张图来表示

![](/img/并发/进程线程模型.jpg)

知道了线程与进程的区别以后，我们来探讨一下什么是并发，什么是并行

## 并发与并行

并发：交替做不同事的能力。简单的说就是一个CPU交替执行程序
并行：同时做不同事的能力。多个CPU一起执行执行。

**只有当CPU至少有两个核心的时候才有可能并行，而能不能并发与CPU的核心数无关，单核CPU也可以实现并发**

看知乎上一个老哥用一句话很形象的形容了并行与并发：

一皇二后是并发，二皇二后是并行。

## 为什么要用多线程

使用多线程最主要的原因是**提高系统的资源利用率**。也就是我们平常说的能够**加快程序运行的速度啊**。现在CPU基本都是多核的，如果你只用单线程，那就是只用到了一个核心，其他的核心就相当于空闲在那里了。

那么问题来了，对于单核是不是就没有必要使用多线程了呢？答案也不是

对于单核，最常用到多线程的地方就是网络和IO。为什么呢

众所周知IO操作相对于CPU而言是非常慢的，CPU等待IO那段时间是空闲的。如果我们需要做类似IO这种慢的操作，可以开多个线程出来，尽量不要让CPU空闲下来，提高系统的资源利用率

![](/img/并发/压榨CPU.jpg)

那么是不是多线程就是一定好呢？

**多线程不是银弹，并不是说线程越多，我们的资源利用效率就越好**。执行IO操作我们线程可以适当多一点，因为很多时候CPU是相对空闲的。如果是计算型的操作，本来CPU就不空闲了，还开很多的线程就不对了（有多线程就会有线程切换的问题，线程切换都是需要耗费资源的，有时候线程切换的时间甚至比你代码执行的时间都要长）

## 在Java中使用线程

Java是支持多线程的，在Oracle的官网中，明确写了开启一个新线程的方法有两种

### 开启线程的两种方法

方法一：实现Runnable接口，重写run()函数，运行start()方法

```java
public class HelloRunnable implements Runnable {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new Thread(new HelloRunnable())).start();
    }

}
```

方法二：继承Thread类，重写run()函数，运行start()方法

```java
public class HelloThread extends Thread {

    public void run() {
        System.out.println("Hello from a thread!");
    }

    public static void main(String args[]) {
        (new HelloThread()).start();
    }

}
```



### 关于启动线程的一些错误观点

- 线程池创建线程也算是一种新建线程的方式
- 通过Callable和FutureTask创建线程，也算是一种新建线程的方式。无返回值是实现runnable接口，有返回值是实现callable接口，所以callable是新的实现线程的方式
- 定时器
- 匿名内部类

上面这些观点都是错的。启动线程的方式只有两种继承thread/实现runnable接口。但是实现runnable接口后，仍然需要调用thread.run。所以严格的来讲**只有一种创建线程方式、两种实现执行单元的方式**

那么为什么上面的观点是错的呢？

因为线程池源码中最后也是new了一个Thread。Callable方式最终也是实现了runnable接口。定时器也是实现了runnable接口。其它的匿名内部类或者lambda表达式都是一样道理。

### 两种启动方法的区别

首先看看Thread的run方法

```java
public void run() {
   if (runnable != null) {
      runnable.run();
   }
}
```

runnable就是我们传入的runnable接口的实现类。

所以Thread的run方法如果有runnable接口就执行runnable的run方法，如果没有就执行自己的逻辑。

这就应证了本质上只有一种创建线程方式这句话。执行的方式不同而已。

我们应该选择哪个方式呢？

实现Runnable接口的方式更好。这是原因

- 实现线程与任务的分离，即我们只需要定义任务，至于交给哪个线程执行由其他策略来具体选择。
- Java不允许多继承，所以我们一旦继承了Thread类，就无法在继承别的类了。

那如果我都写了，代码会如何运行呢？

其实很简单，你都写了的话会执行继承Thread的类中的run方法，因为你重写了这个类的run方法，原本的方法便不会被执行。

### 启动线程的正确方法

启动线程的正确方式就是调用Thread的start方法。

为什么不能调用runnable的run方法呢？因为它本质上是个普通方法，你调用了并没有达到开启线程的目的。

start方法具体做了哪些事情呢？

1. 启动新线程检查线程状态
2. 加入线程组
3. 调用startImpl方法，这是个本地方法。

能否调用两次start方法呢？答案是不能

**在start方法中会判断，如果当前线程已经启动了，再启动会抛出异常。**

### 停止线程的正确方法

错误方法1：被弃用的stop、suspend和resume方法。这三个方法已经被明确弃用了。stop方法是一种“恶意”的中断，一旦执行stop方法，即终止当前正在运行的线程，不 管线程逻辑是否完整，这是非常危险的。也就是说stop方法会破坏原子逻辑

错误方法2：用volatile设置boolean标记位来停止。这种方法在考虑到线程有阻塞的情况下是无法正确中断线程的。

#### 正确方法

**用interrupt来请求停止线程**。**想停止线程，要请求方、被停止方、子方法被调用方相互配合**

interrupt方法的原理：调用Native层代码，标记了标志位，并且根据是否有阻塞状态进行唤醒。

有三个方法可以判断线程是否处于中断状态

- Thread.interrupted，这个方法检查当前线程是否处于中断状态，并且会清除中断标记
- interrupted()除了返回中断标记之外，它还会清除中断标记(即将中断标记设为false)
- isInterrupted()仅仅返回中断标记。

### 如何处理一个不可中断的阻塞呢？

如果线程阻塞是由于调用了 wait()，sleep() 或 join() 方法，你可以中断线程，通过抛出 InterruptedException 异常来唤醒该线程。 但是对于不能响应 InterruptedException 的阻塞，**很遗憾，并没有一个通用的 解决方案。** 但是我们可以利用特定的其它的可以响应中断的方法，**比如:ReentrantLock.lockInterruptibly()，比如:关闭套接字使线程立即返回等方法 来达到目的**

## 线程的几种状态

一张图来概括说明线程的6个状态

![](/img/并发/线程的6个状态.png)

![](/img/并发/线程状态说明.webp)

一般习惯而言，把Blocked(被阻塞）、Waiting(等待）、Timed_waiting(计时等待）都称为阻塞状态

## 线程中的几种重要的方法：

Object中与线程相关方法

| 方法名称                  | 方法说明                               |
| ------------------------- | -------------------------------------- |
| wait()/wait(long timeout) | 获取到锁的线程进入阻塞状态             |
| notify()                  | 随机唤醒被wait()的一个线程             |
| notifyAll();              | 唤醒被wait()的所有线程，重新争抢时间片 |

Thread类中的核心方法

| 方法名称          | 是否static | 方法说明                                                     |
| ----------------- | ---------- | ------------------------------------------------------------ |
| start()           | 否         | 让线程启动，进入就绪状态,等待cpu分配时间片                   |
| run()             | 否         | 重写Runnable接口的方法,线程获取到cpu时间片时执行的具体逻辑   |
| yield()           | 是         | 线程的礼让，使得获取到cpu时间片的线程进入就绪状态，重新争抢时间片 |
| sleep(time)       | 是         | 线程休眠固定时间，进入阻塞状态，休眠时间完成后重新争抢时间片,休眠可被打断 |
| join()/join(time) | 否         | 调用线程对象的join方法，调用者线程进入阻塞,等待线程对象执行完或者到达指定时间才恢复，重新争抢时间片。本质上仍然是wait |
| isInterrupted()   | 否         | 获取线程的打断标记，true:被打断，false：没有被打断。调用后不会修改打断标记 |
| interrupt()       | 否         | 打断线程，抛出InterruptedException异常的方法均可被打断，但是打断后不会修改打断标记，正常执行的线程被打断后会修改打断标记 |
| interrupted()     | 否         | 获取线程的打断标记。调用后会清空打断标记                     |
| stop()            | 否         | 停止线程运行 不推荐                                          |
| suspend()         | 否         | 挂起线程 不推荐                                              |
| resume()          | 否         | 恢复线程运行 不推荐                                          |
| currentThread()   | 是         | 获取当前线程                                                 |

### wait直到以下4种情况之一发生时，才会被唤醒：

- 另一个线程调用这个对象的notify()方法且刚好被唤醒的是本线程；
- 另一个线程调用这个对象的notifyAll()方法；
- 过了wait(long timeout)规定的超时时间，如果传入0就是永久等待；
- 线程自身调用了interrupt()。

### notify唤醒

- notify方法只应该被拥有该对象的monitor的线程调用
- 一旦线程被唤醒，线程便会从对象的“等待线程集合”中被移除，所以可以重新参与到线程调度当中
- 要等刚才执行notify的线程退出被synchronized保护的代码并释放monitor

### wait/notify底层原理

wait方法会将当前线程放入wait set等待被唤醒

1.将当前线程封装成objectwaiter对象node
2.通过objectmonitor::addwaiter方法将node添加到_WaitSet列表中
3.通过ObjectMonitor:exit方法释放当前的ObjectMonitor对象，这样其他竞争线程就可以获取该ObjectMonitor对象
4.最终底层的park方法会挂起线程
notiry方法就是随机唤醒等待池中的一个线程

## 为什么wait() 需要在同步代码块内使用，而 sleep() 不需要

主要是为了通信的可靠，防止死锁等情况的发生。因为很有可能有这种情况

A线程wait前，B线程的notify就全部执行完毕了，A线程就会陷入永久执行的状态。

Sleep为什么可以呢？是因为Sleep是针对当前线程的，和其他线程的关系并不大。并不需要同步操作。

## 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？而sleep定义在Thread类里？

wait(), notify()和notifyAll()是锁级别的操作，而Java中锁是属于某一个对象的。所以是针对锁进行的操作。而且一个线程可能持有多把锁，如果定义在线程就无法进行多种锁的操作了。

## 如果调用thread对象的wait会怎么样呢？

thread对象在运行完毕后会自动执行notifyAll()方法，会造成我们不可预期的结果，所以不建议使用thread对象进行锁。

### notifyAll之后所有的线程都会再次抢夺锁，如果某线程抢夺失败怎么办？

会继续等待线程执行完，然后继续抢夺锁。此时线程处于BLOCKED状态。

## wait和Sleep的区别

sleep方法可以让线程进入Waiting状态，并且不占用CPU资源，但是不释放锁，直到规定时间后再执行，休眠期间如果被中断，会抛出异常并清除中断状态。

sleep和wait的区别有： 

1，这两个方法来自不同的类分别是Thread和Object  

2，最主要是sleep方法**没有释放锁**，而wait方法**释放了锁**，使得敏感词线程可以使用同步控制块或者方法。 

 3，wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在    任何地方使用 

4,sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常

他们都会释放CPU资源和响应中断