---
layout:     post
title:      可能是最通俗易懂的源码解读之OKHTTP源码解读
subtitle:   图文并茂，拒绝随意乱贴代码，真正从设计角度理解OkHttp
date:       2020-10-01
author:     MLX
header-img: img/android_bg.jpg
catalog: 	 true
tags:
    - Android
    - 源码
    - OkHttp
typora-root-url: ..
---

## 前言

现在Android界的网络请求已经是OkHttp和Retrofit的天下了，Retrofit本质上也是将请求委托给了OkHttp，所以我们如果想要能够更加全面的使用和掌握OkHttp，了解其源码是必不可少的。

本文拒绝贴大段大段的代码，这种文章我看了只会觉得恶心。

源码都在那里，需要你给我看？我自己看不就行了么，所以本文将从设计思想和流程角度来分析OkHttp是如何一步一步的完成请求的。

![](/img/emoji/出发.jpg)

## 简单使用

同步方式和异步方式殊途同归，而且异步方式更多了异步和线程的概念，所以本文将直接分析异步，同步的话流程也是一样的。

```kotlin
val client=OkHttpClient().newBuilder().build()
val request=Request.Builder().url("https://www.baidu.com").build()
val call = client.newCall(request)
call.enqueue(object :Callback{
      override fun onFailure(call: Call, e: IOException) {
          println("onFailure:$e")
      }

      override fun onResponse(call: Call, response: Response) {
          println("onResponse:${response.body?.string()}")
      }

})
```

这可以说是最简单的使用方式了。

使用 OkHttp 基本是以下四步：

1. 创建 `OkHttpClient` 对象
2. 创建`Request`请求对象
3. 创建`Call`对象
4. 同步请求调用`call.execute()；`异步请求调用`call.enqueue(callback)`

这都是啥？一个简单的请求为啥需要这么多对象呢？

## 简单架构

那好，我们来分析一下他们的职责，其实啊一次网络请求和寄快递没啥区别。

首先，你在淘宝买了一个东西，发现不满意，要换货，你得去快递点(`OkHttpClient` )，然后填写快递单(`Request`)表明要寄给谁，寄的啥东西，填完以后你交个快递小哥，小哥把你这个快递给你寄出去(`Call`)。如果是同步请求(`call.execute`)的话，你就在这等着快递寄出去，然后卖家再发给你换好的货(`Response`)。显然，这么等的话怕是等个三四天，所以我们把快递给了快递小哥以后，告诉小哥我的电话(`CallBack`回调)，说货到了通知我(触发回调 `onResponse/onFailure`)。

这样一来是不是很简单了

什么？还不够清晰明了？靠，我上一张图，不怕你不知道

<img src="/img/okhttp源码/简单架构.png" style="zoom: 67%;" />

好，到此结束，OKHTTP分析完毕！

什么？这就完事了？我不是听说还有啥拦截器，什么责任链，什么缓存balabla的，你这叫我和面试官如何对线？

好吧，那我们接着下面看OkHttp做了什么。

## 构建OkHttpClient对象

我们一步一步来，先分析我们如何鬼使神差的走进快递点的，啊不，构建OkHttpClient对象的

```kotlin
val client=OkHttpClient().newBuilder().build()
```

这行代码是构建OkHttpClient对象的，很明显有个Builder对象，这明眼人一看就知道是构建者模式去构建OkHTTPClient对象。

什么？构建者模式是什么

构建者模式一般适用于创建比较复杂的对象使用的，可以屏蔽用户对细节的感知balabala

我最讨厌说定义了，我这么说吧，你如果创建一个对象构造函数中参数特别多的时候，大部分情况下你用构建者就行了。

为什么？就比如说你想整个车，你可以直接说，来奔驰，给我整俩车。你对如何造车完全不知道，但这并不影响你提车泡妹。

可是你不是说参数比较多的时候用构建者么？

没错，参数比较多的时候你是不是得一个个传参，还得小心参数的位置啥的？当然了，在Kotlin中可以指定哪个参数，它本质上和构建者也差不多。你也不想提车的时候还得小心翼翼的和厂家一一说明要求吧，我得有个四个轮的车，白色的，能坐四个人的等等要求。

所以构建者模式就是为了解决此问题，你可以没有要求，我就使用默认值，你可以有很多要求，甚至可以重复，反正我只在你提车的时候最终确认即可给你符合你要求的车。

所以如果使用构建者模式的话，我们不必为参数的位置和忘了传什么参数而烦忧，我们可以写出如下代码：

```kotlin
val client=OkHttpClient()
    .newBuilder()
    .dispatcher()
    .callTimeout()
    .authenticator()
    .addInterceptor()
    .cache()
    .build()
```

你看你可以使用构建者模式去创建出符合你所有要求的对象，不用担心参数位置，或者忘记传哪个参数。

当然，本篇不是讲设计模式的，随后我将会开辟一个新的系列，专门讲设计模式。这里点到为止。

我们继续回到我们的OkHttp来，使用Builder对象创建了OkHttpclient对象过程中，其实给OkHttpclient创建了一系列的配置，我们这里简要的看一下，在newBuilder方法中创建了一个Builder对象：

```kotlin
class Builder constructor() {
    internal var dispatcher: Dispatcher = Dispatcher()//调度器，一会讲
    internal val interceptors: MutableList<Interceptor> = mutableListOf()//拦截器，一会也会讲
    internal val networkInterceptors: MutableList<Interceptor> = mutableListOf()//网络拦截器，也会讲
    ...//定义很多其他对象
}
```

在这里省略了很多对象，只列出了三个比较重要的对象，一会都会讲的。

build方法真正构建了OkHttpclient对象：

```kotlin
fun build(): OkHttpClient = OkHttpClient(this)
```

这个this是什么？

这个build方法是Builder对象的build方法，this当然是Builder对象啦。这里真正创建了一个OkHTTPClient对象，并把Builder对象自身传了过去。在OkHttpclient对象的构造方法中有如下代码：

```kotlin
open class OkHttpClient internal constructor(
  builder: Builder
) : Cloneable, Call.Factory, WebSocket.Factory {
  @get:JvmName("dispatcher") val dispatcher: Dispatcher = builder.dispatcher //调度器
  @get:JvmName("interceptors") val interceptors: List<Interceptor> =
      builder.interceptors.toImmutableList()//拦截器集合
  @get:JvmName("networkInterceptors") val networkInterceptors: List<Interceptor> =
      builder.networkInterceptors.toImmutableList()//网络拦截器集合
}
```

可以看到，最终builder对象中的拦截器全部给了OkHttpClient对象，这也正是构建者模式的体现之处。

简而言之，就是OkHttpClient里面定义了很多我们不知道的对象。正如你寄快递的时候，你并不知道快递是如何寄出去的，OkHttp帮你完成了很多的细节工作。

接下来就是构建Request对象了

## 构建Request对象

你想寄快递，必须填写快递单，写你要寄给谁，寄到哪里，怎么寄平邮还是快件，这一切就是Request对象的职责。它负责记录你的请求信息。

```kotlin
val request=Request.Builder().url("https://www.baidu.com").build()
```

经过上面的分析，我们已经知道，构建者Builder中所有的参数最终全部会给到Request对象中。所以我们直接看看Request对象的构造方法中有什么东西～

```kotlin
class Request internal constructor(
  @get:JvmName("url") val url: HttpUrl,//ur,也就是你要发送的地方
  @get:JvmName("method") val method: String, //请求方法，GET/POST
  @get:JvmName("headers") val headers: Headers,//请求头，一些备注信息或者请求信息
  @get:JvmName("body") val body: RequestBody?,//请求的内容，就是你具体要发送的快递不能
  internal val tags: Map<Class<*>, Any>
) {
	....
}
```

注释已经讲的很清楚了，关于HTTP网络这块，大家不太懂的可以看我之前的文章，从HTTP表层到原理全部都有讲解。

接下来也没啥内容了，该轮到Call对象了

## 创建Call对象

```kotlin
val call = client.newCall(request)
```

正如你想寄快递，你必须填写好快递单交给快递站的小哥才行。

这里你已经填好了快递单，你需要交给快递站，然后快递站派出快递小哥帮你发快递。

快递小哥就是Call，我们看看是Call是什么东东：

```kotlin
interface Call : Cloneable {

  fun request(): Request//返回请求信息，就是返回你填写的快递单
  @Throws(IOException::class)
  fun execute(): Response//同步请求，就是你在快递站傻等~
  fun enqueue(responseCallback: Callback)//异步请求，接受回调参数。就是你告诉快递小哥你电话，让小哥寄快递
  fun cancel()//取消请求，就是你取消寄快递
  fun isExecuted(): Boolean//是否正在请求，就是你的快递寄出去了没，寄到哪了
  fun isCanceled(): Boolean//是否是取消状态
  fun timeout(): Timeout //超时时间，就是你这个快递寄出去半年了都没动静，你就认为中途丢了
  public override fun clone(): Call
  fun interface Factory {
    fun newCall(request: Request): Call
  }
}
```

Call本质上是个接口，也符合我们的面向接口编程。它里面定义了很多方法，在上面注释中我也都详细阐述了。可是接口并不能具体帮我们干活啊，就像你知道你要找一个快递小哥，快递小哥是一个抽象的概念并不是一个具体存在的人，你只知道快递小哥能帮你寄快递，这个寄快递就是一个抽象的方法。所以我们需要知道到底是哪个快递小哥帮我们寄了快递。

我们看一下这个`newCall`方法：

```kotlin
//OkHttpClient.kt
override fun newCall(request: Request): Call = RealCall(this, request, forWebSocket = false)
```

啊知道了，`RealCall`才是真正为我们服务的那个快递小哥。创建RealCall的过程中，我们传进去一共三个参数,第一个this自然就是OkHttpclient对象本身了，第二个参数是请求信息也就是快递单，第三个参数是用于指明不是webSocket请求。暂时不用管第三个参数

好，我们现在万事俱备只欠东风，所有的对象都已经创建完成了，可以寄快递了吧？

## 发送请求

发送请求就是将你的电话号告诉给快递小哥，快递小哥寄出去以后，收到快递再给你打电话告诉你快递到了或者丢了。对应的就是以下代码。

```kotlin
call.enqueue(object :Callback{
    override fun onFailure(call: Call, e: IOException) {
        println("onFailure:$e")
    }
    override fun onResponse(call: Call, response: Response) {
        println("onResponse:${response.body?.string()}")
    }
})
```

前面也说了call.enqueue是一个异步方法，我们既然是从源码开始学习的，自然不能只停留在表面，当然要深入源码去探索，看看这个发送的过程到底是怎么样的过程。在上面我们知道，这个快递小哥是一个宽泛的概念(接口)，真正执行任务的时候要具体到某个人的(实现类)，这个具体的人就是RealCall对象，所以我们看看`RealCall.enqueue`方法。

### RealCall.enqueue

```kotlin
//RealCall.kt
override fun enqueue(responseCallback: Callback) {
  //检查是否执行了两遍，也就是说你是不是同一个快递想要发两次，这当然是不行的。
  check(executed.compareAndSet(false, true)) { "Already Executed" }
  //请求后会立即调用，相当于监听请求的开始事件
  callStart()
  //将请求交给调度器来决定什么时候请求
  client.dispatcher.enqueue(AsyncCall(responseCallback))
}
```

这个方法很有意思，前面两行注释已经有了，就不讲了，最后一行首先创建了一个AsyncCall对象，并且把回调给了AsyncCall。这里先不研究AsyncCall，一会再说。接下来调用了`dispatcher.enqueue`方法，什么时候发送和发送的过程交给了dispatcher(调度器)。由它来决定何时，如何发送。

不太明白？

dispatcher是调度员的意思，在你寄快递的例子中就是本地物流中心，它负责决定整个收发快递的流程，比如发送的策略，是否发送等等。

我们看一下定义

#### Dispatcher

```kotlin
class Dispatcher constructor() {
 //最大请求数，也就是最多只有64辆发送快递的车，用完了就没了
  @get:Synchronized var maxRequests = 64  
	//同一主机最大请求数量，加入你退货的目的地是北京，发往北京的快递车最多只有5辆
  @get:Synchronized var maxRequestsPerHost = 5

	//线程安全的单例模式，线程池的获取用于线程调度。
  @get:Synchronized
  @get:JvmName("executorService") val executorService: ExecutorService
    get() {
      if (executorServiceOrNull == null) {
        executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
            SynchronousQueue(), threadFactory("$okHttpName Dispatcher", false))
      }
      return executorServiceOrNull!!
}

 //准备的队列，也就是进入了打包的车
  private val readyAsyncCalls = ArrayDeque<AsyncCall>()
  //异步发送队列，也就是进入了准备出发的车
  private val runningAsyncCalls = ArrayDeque<AsyncCall>()
  //同步发送队列，同样是进入了准备出发的车
  private val runningSyncCalls = ArrayDeque<RealCall>()
 	...
}
```

这个Dispatcher有上面这么几个比较重要的字段，通过上面的注释可以得到，Dispatcher对象定义了最大请求数和同一主机的最大请求数。。然后三个队列，我们只研究准备队列和异步发送队列，因为同步发送队列是一样的道理。

我们知道了这个Dispatcher对象的几个字段之后，我们接着看它的enqueue方法

### Dispatcher.enqueue

```kotlin
//Dispatcher.kt
internal fun enqueue(call: AsyncCall) {
  //确保线程安全
  synchronized(this) {
    //把快递放到打包车中
    readyAsyncCalls.add(call)
    //如果不是websocket，前面可知forWebSocket为false
    if (!call.call.forWebSocket) {
      //查询有没有退货到北京的车
      val existingCall = findExistingCallWithHost(call.host)
      //复用退货到北京的计数器callsPerHost，用于统计发往北京快递车数量
      if (existingCall != null) call.reuseCallsPerHostFrom(existingCall)
    }
  }
  //准备发送快递
  promoteAndExecute()
}
```

首先是放进准备队列中，也就是把快递放进了打包的车中。然后先看看有没有到北京的快递车，有的话直接用它的计数器，用来统计现在有几辆发往北京的快递车了，也就是检查同一个主机已经有几个请求了。然后准备发送

### Dispatcher.promoteAndExecute

```kotlin
private fun promoteAndExecute(): Boolean {
  this.assertThreadDoesntHoldLock()
  //收集所有要发出去的快递，也就是要执行的请求
  val executableCalls = mutableListOf<AsyncCall>()
  val isRunning: Boolean
  synchronized(this) {
    val i = readyAsyncCalls.iterator()//得到迭代器对象用于遍历
    while (i.hasNext()) {//遍历
      val asyncCall = i.next()//得到下一个快递
      //很重要的判断，如果64个快递车都出发了，也就没快递车了，那么将无法请求
      if (runningAsyncCalls.size >= this.maxRequests) break 
      //发往北京的5辆快递车也都走了，那么继续下一个快递
      if (asyncCall.callsPerHost.get() >= this.maxRequestsPerHost) continue // Host max capacity.
      //上面都通过了，说明有车，并且发往北京的快递车也还有，那么就离开打包车
      i.remove()
      //把去往北京的快递车数量+1
      asyncCall.callsPerHost.incrementAndGet()
      //把快递保存起来
      executableCalls.add(asyncCall)
      //将快递放到即将出发的车中
      runningAsyncCalls.add(asyncCall)
    }
    isRunning = runningCallsCount() > 0
  }
  //循环遍历，将所有的快递寄出去
  for (i in 0 until executableCalls.size) {
    val asyncCall = executableCalls[i]
    asyncCall.executeOn(executorService)
  }
  return isRunning
}
```

上面的代码很长，但其实只做了这么三件事

- 先判断还有没有快递车了，没有车的话什么快递都寄不出去了，跳出循环
- 在判断同一目的地的车辆还有没有了，目的地如果是北京，那就是判断去北京的车还有没有了，没有的话就看下一个快递。如果还有车的话，就把它装进即将出发的车里，然后计数+1，表示又占用了一辆去北京的车
- 再次循环，将所有要寄出去的快递寄出去

最终啊快递出发还是回到了AsyncCall的executeOn方法，我们先看看AsyncCall对象是什么

```kotlin
internal inner class AsyncCall(
  private val responseCallback: Callback
) : Runnable {
}
```

其它的我们都不需要关注，我们只需要关注两点，第一它接受了回调，也就是你的电话号。第二，它继承了Runnable，这是什么？这不就是线程么，创建Thread，实现Runnable接口。没错就是这样喵

上面说到，最终发送是调用了`asyncCall.executeOn(executorService)`方法，那我们具体看一下这个方法

### asyncCall.executeOn

```kotlin
fun executeOn(executorService: ExecutorService) {
  client.dispatcher.assertThreadDoesntHoldLock()
  //暂时定义发送没成功
  var success = false
  try {
    //使用线程池来执行自身
    executorService.execute(this)
    //发送成功了
    success = true
  } catch (e: RejectedExecutionException) {
    val ioException = InterruptedIOException("executor rejected")
    ioException.initCause(e)
    noMoreExchanges(ioException)
    //失败回调
    responseCallback.onFailure(this@RealCall, ioException)
  } finally {
    if (!success) {
      //结束
      client.dispatcher.finished(this) 
    }
  }
}
```

别看代码很长，其实就是做了一件事，这个AsyncCall把自己加入到了线程池，然后由线程池来开启线程执行自己的run方法。

小伙伴会问了，什么是线程池？

线程池可有讲究了，咱们本篇研究的是OkHttp，这里就不讨论线程池了。以后的文章中会专门研究线程的种种，包括线程池。这里咱们只研究一点，就是这是一个什么样的线程池

还记得刚才Dispatcher类中定义了单例并且线程安全的线程池么

```kotlin
@get:Synchronized
@get:JvmName("executorService") val executorService: ExecutorService
  get() {
    if (executorServiceOrNull == null) {
      //定义了一个缓存线程池
      executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS,
          SynchronousQueue(), threadFactory("$okHttpName Dispatcher", false))
    }
    return executorServiceOrNull!!
}
```

这里就是定义了一个缓存的线程池，什么是缓存线程池？就是具有缓存功能的，如果一个线程工作完了并且60s之内又有请求过来，就复用刚才那个线程，这提高了性能。

然后交由线程池之后，线程池会开启线程执行asyncCall的run方法

### asyncCall.run

```kotlin
override fun run() {
    threadName("OkHttp ${redactedUrl()}") {
      //定义响应标志位，用于表示请求是否成功
      var signalledCallback = false
      timeout.enter()
      try {
        //寄快递过程中~~~得到了换回来的货物
        val response = getResponseWithInterceptorChain()
        //走到这步没出错，代表寄快递成功了  
        signalledCallback = true
        //打电话给你表示货到了  
        responseCallback.onResponse(this@RealCall, response)
      } catch (e: IOException) {
        //如果寄快递过程没出错，但是try/catch还是报异常了只能说 onResponse中出错了，这就是用户的锅
        if (signalledCallback) {
          Platform.get().log("Callback failure for ${toLoggableString()}", Platform.INFO, e)
        } else {
          //失败回调  
          responseCallback.onFailure(this@RealCall, e)
        }
      } catch (t: Throwable) {
        cancel()//取消请求
        //okhttp自己的锅，发送过程中出现了错误  
        if (!signalledCallback) {
          val canceledException = IOException("canceled due to $t")
          canceledException.addSuppressed(t)
          //失败回调  
          responseCallback.onFailure(this@RealCall, canceledException)
        }
        throw t
      } finally {
        //结束  
        client.dispatcher.finished(this)
      }
    }
  }
}
```

走到这一步不容易，核心流程算是走完了。最终是通过getResponseWithInterceptorChain方法发出去快递并且得到换回来的货。

看懵了？不要紧，我们来梳理一下流程

我要放大招了！

![](/img/okhttp源码/okhttp流程.jpg)

流程如下：

1. 进入快递点，对应创建okhttpClient对象

2. 填写快递单，对应创建Request对象

3. 将快递单交给快递小哥，对应创建RealCall对象并将Request对象交给它

4. 让小哥寄快递并告诉自己的手机号，对应调用Call的enqueue方法，并传递回调

5. 小哥把快递交给了调度员，并且把电话号告诉了开车的老司机，然后调度员把快递放到了打包车中，对应dispatcher的enqueue方法和

6. 调度员询问还有没有车了，以及有没有北京的车了两个判断。对应dispatcher的promoteAndExecute方法

7. 答案是有车的话，就把老司机叫过来，给他分配一辆车，让他开车去把快递送出去。对应于线程池分配一个线程去执行AsyncCall的run方法
8. 老司机开车一路上会遇到安检，收费站等等地方，对应于拦截器链。
9. 老司机不管是送到了以后拿到了要换的货还是没送到，老司机都会回来，并且照着快递小哥给的电话给你打电话告诉你结果。对应于回调方法的触发

这边是主线流程，是不是相当的简单呢？和我们寄快递没有一点点差别，所以说啊，代码来源于生活，又抽象与生活。

相信有小伙伴肯定不满足于如此简单的主线流程，那么我们就进入OkHttp的支线剧情，看看拦截器链具体做了什么

